# coding_in_RTU
everyday coding in RTU

---
<details>
<summary> 정리 템플릿 </summary>

### (문제 등급) 문제 번호 문제 이름
- **문제설명** :
- **느낀점** :
- **개념정리** (선택사항) :

</details>

---

<details>
<summary> 9/3 1일차 </summary>

### 브론즈 23881번 알고리즘 수업 - 선택 정렬 1
- **문제설명** : 선택정렬 수도코드를 제공하고 교환횟수를 체크하여 해당 교환횟수 번째에 교환되는 두개의 수를 출력하는 문제였다. 
- **느낀점** : 선택정렬에 대한 개념이 헷갈려 gif를 다시 보고 코드로 구현했다. 배열의 0번부터 확인하는 버전과 배열의 마지막번째부터 확인하는 버전 둘 다 구현해보았는데 반복문과 크기를 체크하는 것을 꼼꼼히 확인해야해서 어려웠다. 

- *selection sort* <br>
<img src = "https://github.com/whattheyeb/coding_in_RTU/blob/main/img/selection-600.gif" width = 300>
</details>

<details>
<summary> 9/4 <2일차> </summary>

### 브론즈 23882번 알고리즘 수업 - 선택 정렬 2
- **문제설명** : 이번 문제는 23881번 문제에서 약간 변형된 버전으로, 특정 교환 횟수 번째 이후의 정렬을 출력하는 문제였다. 
- **느낀점** : 이제 선택정렬을 구현하는 코드는 비교적 빠르게 작성할 수 있게 되었다. 하지만 for문 안에서 바로 답을 출력하려고 해서 첫번째 시도에서는 실패했었다. 선택정렬을 하는 for문 안에서는 결과를 바로 출력하기보다 flag 사용하거나 배열을 정렬하는 방식을 사용해야겠다.

### 브론즈 10871번 X보다 작은 수
- **문제설명** : 배열과 특정 수를 입력받고 배열 안의 숫자들 중 특정 수보다 작은 수들을 출력한다.
- **느낀점** : 이제 vector를 활용하여 배열을 입력받는 것을 습관들여야겠다.
- **개념정리** : vector 는 c++ 표준라이브러리 (#include <vector>) 에서 제공하는 동적 배열이다. push_back(value) : 맨 뒤에 값 추가, size() : 현재 원소 개수, empty() : 비었는지 확인, clear() : 모든 원소 제거, 초기 정의 : vector<int> v1(10);

### 브론즈 10952번 A + B - 5
- **문제설명** : 정수 a, b를 입력받고 a+b를 출력하는 코드를 작성하는 것, 단, a과 b 둘다 0일때는 아무것도 출력하지않고 종료한다.
- **느낀점** : while 문을 사용하면 a와 b 둘다 0일때에도 둘이 더한 값인 0을 출력하게된다. 그래서 do-while문을 사용했다.

</details>

<details>
<summary> 9/5 <3일차> </summary>

### (브론즈 3) 10818번 최소, 최대 
- **문제설명** : n개의 정수가 주어지고, 이 정수들의 값을 비교하여 최솟값과 최댓값을 구하는 프로그램을 작성
- **느낀점** : ez

### (브론즈 4) 25304번 영수증 
- **문제설명** : 총 금액과 물건의 종류에 대한 입력이 주어지며, 물건의 가격과 개수를 이용하여 실제 담은 금액과 영수증의 총 금액이 일치하는지 확인하는 프로그램을 작성
- **느낀점** : ez

### (브론즈 4) 15552번 빠른 A+B 
- **문제설명** : 정수 a, b를 굉장히 많이 입력받고, a+b를 출력하는 프로그램
- **느낀점** : 새로운 개념을 배웠다!!
- **개념설명** : cin.tie(NULL); 과 sync_with_stdio(false); 를 코드 앞에 작성한 후, endl 대신 \n 을 사용하면 된다. 다음 링크에 설명이 잘 되어있으니 참고해라 https://www.acmicpc.net/blog/view/128 

</details>

<details>
<summary> 9/6 <4일차> </summary>

### (브론즈 5) 10951번 A + B - 4
- **문제설명** : 두 정수 A + B를 입력받은 다음, A + B 를 출력한다.
- **느낀점** : 
- **개념정리** : EOF(End of File) 설정을 해줘야한다. 키보드 입력으로는 윈도우에서 Ctrl+Z 를 눌러 EOF를 발생시킨다. 그럼 반복문에서 조건을 어떻게 설정해야할까? 바로 그냥 while(cin >> a >> b) 이런식으로 조건식에 cin을 넣으면 된다. 

### (브론즈 3) 2562번 최댓값
- **문제설명** : 9개의 다른 자연수가 입력되며, 최댓값과 그 최댓값이 몇번째 수인지를 구하는 프로그램이다.
- **느낀점** : vector를 쓰니까 확실히 코드도 간결해지고 이해하기 쉬워졌다. 번외로 인덱스는 항상 현실 숫자 - 1 라는 것을 기억하자..

### (브론즈 3) 10810번 공넣기
- **문제설명** : 바구니 개수, 공을 넣는 회차 수가 주어진다. 그리고 각 회차마다 공을 넣을 바구니 번호의 범위 (두 개의 수)와 넣을 공의 번호가 주어진다. 공을 넣는 회차가 전부 끝난후, 바구니에 들어있는 공의 번호가 어떻게 되어있는지 출력한다. (단, 각 바구니에는 하나의 공만 들어있을 수 있다. 공이 이미 들어있는 경우 들어있는 공을 빼고 새로운 공을 넣는다)
- **느낀점** : 문제설명이 너무 길어서 읽는 데 힘들었지만 막상 푸는건 쉬웠다. for문 안에 또 다른 for문을 사용할때 조건식의 변수(i, j, k)를 다르게하고 통일시키자

</details>

<details>
<summary> 9/7 <5일차> </summary>

### (브론즈 2) 10813번 공바꾸기
- **문제설명** : 10810번과 기본적인 문제 토대는 같고, 바구니에 들어있는 공을 여러 회차동안 바꾼 후, 최종적으로 바구니에 있는 번호는 무엇인지 출력하는 프로그램을 작성한다
- **느낀점** : 10810번과 매우 비슷하고 swap함수를 사용하여 쉽게 해결했다.

### (브론즈 3) 5597번 과제 안 내신 분..?
- **문제설명** : 30명의 학생들 중 2명의 학생이 과제를 제출하지 않았다. 28개의 학생 번호가 입력으로 들어오면 그 중 제출하지않은 두 학생의 번호를 알아내어 출력한다.
- **느낀점** : for문 안에 변수를 선언하면 그 바깥에서는 초기화된다는 것을 몰랐다. 디버깅 출력 코드를 활용하여 알아내서 다행이다...

### (브론즈 2) 10811번 바구니 뒤집기
- **문제설명** : 10810, 10813번과 기본적인 문제 토대가 같다. 번호가 적힌 바구니를 여러 회차동안 역순으로 만든후, 최종적인 바구니 배열을 출력하는 프로그램을 작성한다.
- **느낀점** : 역순으로 만드는 코드에서 시간을 많이 썼다. 
- **개념정리** : 3번부터 5번 배열 원소를 뒤집어야한다. 그러면 바꾸는 작업이 2번 일어나게된다. (3번과 5번, 4번과 4번) -> swap을 활용한다면, 3부터 시작해서 (3 + 5) / 2 = 4까지, 2번만 반복한 후 끝나야하므로 num1부터 시작하여 num1 + num2 / 2 에서 멈춰야한다. 

### (브론즈 1) 1546번 평균
- **문제설명** : 기말고사 값들이 주어진다. 이 값 중 최댓값을 고르고 모든 점수를 각 과목의 점수 / 최댓값 * 100 을 진행한후 평균을 출력한다.
- **느낀점** : 처음에는 최댓값인 과목의 점수도 위와같이 진행하는지 모르고 있다가 질문게시판을 보고 깨닫게 되었다. 
- **개념정리** : c++ 에서는 int 끼리 나눗셈을 하면 소수점 이하의 숫자는 버려지기 때문에 casting을 해줘야한다. 이 문제를 풀 때에는 static_cast<type>(변수명) 이렇게 해줬다. (double 또는 float 로 선언해도 동일하다. ) 다음 티스토리를 보고 참고했다. https://code-studies.tistory.com/20 

</details>

<details>
<summary> 9/9 <6일차> </summary>

### (실버 5) 2941번 크로아티아 알파벳
- **문제설명** : 문제가 길어서 이미지로 첨부 <img src = "https://github.com/whattheyeb/coding_in_RTU/blob/main/img/bj2941.png" width = 400>
- **느낀점** : 문제는 풀긴했지만 if문남발에다가 복잡하게 작성한 것같아서 챗지피티에게 피드백을 받을 예정이다. 개인적으로 다음 인덱스로 바로 넘어가기위해 for문의 인덱스에 해당하는 i 를 사용한 방법은 마음에 든다. (핵심 아이디어는 “매칭되면 카운트 증가 후 인덱스 건너뛰기”)

### (브론즈 5) 27866번 문자와 문자열
- **문제설명** : 문자열과 숫자를 입력받고, 입력받은 숫자번째에 해당하는 문자를 출력한다. 
- **느낀점** : 기초문제여서 쉽게 풀었다.

### (브론즈 5) 9086번 문자열
- **문제설명** : 여러개의 문자열을 입력받고, 각 문자열의 첫번째 문자와 마지막 문자를 연속해서 출력한다. 
- **느낀점** : size() 함수를 사용하여 쉽게 풀 수 있다.

### (브론즈 5) 11654번 아스키 코드
- **문제설명** : 알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하는 프로그램을 작성하시오.
- **느낀점** : 몰라서 찾아봤다...
- **개념설명** : c++ 에서 문자를 아스키코드로 변환해서 하려면 다음과 같이 코드를 작성하면 된다고 한다. int ascii_value = static_cast<int>(input);

### (브론즈 4) 11720번 숫자의 합
- **문제설명** : 숫자개수와 띄어쓰기없이 쓰여진 숫자배열이 입력된다. 입력으로 주어진 숫자 N개의 합을 출력한다. 
- **느낀점** : 문자열과 관련된 문제라고 생각 안하고 있다가 공백없이 숫자 N개가 주어진다는 글을 보고 문자열로 숫자배열을 입력받고, 각 인덱스로 접근후 아스키코드값을 빼서  더해야겠다는 생각을 했다. 

### (브론즈 2) 10809번 알파벳 찾기
- **문제설명** : 문자열에서 알파벳이 처음 등장하는 위치를 찾아서 저장후 모든 알파벳에 대해 출력한다. 
- **느낀점** : 알파벳 배열을 잘못써서 틀렸다는 게 너무 웃김 (tuvwxyz...) 이런건 직접 찾아서 그냥 복사 붙여넣기하도록 하자. 

</details>

<details>
<summary> 9/10 <7일차> </summary>

### (브론즈 2) 2675번 문자열 반복
- **문제설명** : 테스트케이스 개수 N과 각 문자열 S와 반복횟수 R을 입력받는다. 문자열의 각 문자를 R번씩 반복하여 출력한다. 예시 : (입력) 3 ABC (출력) AAABBBCCC
- **느낀점** : ez

### (브론즈 2) 2908번 상수
- **문제설명** : 각 두개의 3자리 숫자를 입력받는다. 이 숫자를 뒤집은후 크기를 비교해 더 큰 숫자를 출력한다
- **느낀점** : vector의 push_back() 함수를 활용하고 싶어서 int 변수는 하나도 쓰지않았다. 챗지피티의 피드백을 읽고나니 불필요하게 저장공간을 썼음을 알 수 있었다.  

### (브론즈 2) 5622번 다이얼
- **문제설명** : 사진 참고 <br> <img src = "https://github.com/whattheyeb/coding_in_RTU/blob/main/img/bj5622.png" width = 450>
- **느낀점** : if문 폭탄으로 문제를 풀어서 조금 찝찝하다. 챗지피티의 코드를 봤는데 너무 충격적으로 잘짜서 충격임. 알파벳에 시간을 매핑해서 미리 정의한다는 개념을 사용한 것이 대박인거같다. 19줄을 3줄로 줄임

</details>

<details>
<summary> 9/11 <8일차> </summary>

### (브론즈 3) 11718번 그대로 출력하기
- **문제설명** : 입력 받은 문자열을 출력하는 프로그램을 작성하라 (문자열은 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져있다.)
- **느낀점** : 10951번과 비슷한 문제이다. 다만 공백이 포함되어있기때문에 cin이 아닌 getline을 사용해야한다는게 달랐다.
- **개념정리** : #include <string> 라이브러리의 getline(cin, 변수명) 함수를 사용하여 공백이 포함된 문자열 한줄을 입력받을 수 있다. 

### (브론즈 3) 2738번 행렬 덧셈
- **문제설명** : N*M 크기의 두 행렬이 주어졌을때, 두 행렬을 더하는 프로그램을 작성하라
- **느낀점** : 2차원배열을 오랜만에 써서 헷갈렸지만 문제자체가 어렵지않아 간단하게 이중 for문을 사용하여 풀 수 있었다.

</details>

<details>
<summary> 9/12 <9일차> </summary>

### (브론즈 5) 2744번 대소문자 바꾸기
- **문제설명** : 영어 소문자와 대문자로 이루어진 단어를 입력받은 뒤, 대문자는 소문자로, 소문자는 대문자로 바꾸어 출력하는 프로그램을 작성하시오.
- **느낀점** : 대소문자의 아스키코드 차이만큼 더해주고 빼는 로직을 사용하여서 쉬웠다.

### (브론즈 5) 15964번 이상한 기호
- **문제설명** : 입력받은 두 숫자에 대해 A＠B = (A+B)×(A-B) 를 계산한다
- **느낀점** : 그냥 long int 만 쓰면 해결되지않아서(100점 만점 중에 30점만 준다) 구글링을 통해 해결했다. 
- **개념정리** : 두 int 의 값이 커서 int 변수에 담을 수 없다면 long long int를 사용해야한다. long long int output = 1LL * (a + b) * (a - b);

### (브론즈 4) 31403번 A + B - C
- **문제설명** : A, B, C 를 각각 수와 문자열로 생각했을때, A + B - C를 출력하라
- **느낀점** : 테스트케이스에 한자리수만 있어서 단순히 char로 입력받고 '0'만큼 빼서 더하고 빼면 되겠다고 생각했는데 입력 부분에 a, b, c는 1에서 1000사이의 숫자라고 쓰여있는 것을 확인하게 되었다. 

### (브론즈 2) 8958번 OX 퀴즈
- **문제설명** : "OOXXOXXOOO"와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다.
"OOXXOXXOOO"의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다.
OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.
- **느낀점** : 이전 문제의 결과(O,X)에 대해 저장하는 배열 prev를 만들었다. 그런데 X 인 경우에 prev를 0으로 저장하지 않아서 이전 문제의 결과가 X인데도 불구하고 1로 저장되는 경우가 있었다. if 조건 설정과 예외처리를 꼼꼼히 봐야겠다. 로직은 백준 1316번과 비슷해서 쉽게 생각해낼 수 있었다. 

</details>

<details>
<summary> 9/13 <10일차> </summary>

### (브론즈 3) 10250번 ACM 호텔
- **문제설명** :  호텔의 층 수, 각 층의 방 수, 몇 번째 손님인지에 대한 입력이 들어오면, N 번째로 도착한 손님에게 배정될 방 번호를 계산하는 프로그램이다. (링크 참고 : https://www.acmicpc.net/problem/10250 )
- **느낀점** : 문제가 길어서 어려울 거라 생각했는데 2차원배열도 쓰지않고 쉽게 풀 수 있었다. 

### (브론즈 3) 4153번 직각삼각형
- **문제설명** : 주어진 세변의 길이로 삼각형이 직각인지 아닌지 구분하시오.
- **느낀점** : 빗변의 길이의 제곱과 나머지 두변의 길이의 제곱의 합이 같으면 직각삼각형이라는 정의를 그대로 코드에 적용하려고 했다. [1] 최댓값 구하기 [2] 길이의 제곱을 구해서 같은지 확인하는 함수 적용 [3] 출력 이 로직으로 작성했다. [1]파트에서 좀 더 효율적으로 코드를 짤 수 있을지 고민해봐야겠다. 

### (브론즈 3) 30802번 웰컴 키트
- **문제설명** : 참가자들에게 티셔츠와 펜을 줄 건데 얼만큼 준비해야하는지 구하는 문제
- **느낀점** : '펜을 P자루씩 최대 몇 묶음 주문할 수 있고, 그때 한 자루씩 몇 개 주문하는지' 이 말이 이해가 안가서 그냥 입출력 예시 보고 몫과 나머지인가 추측했는데 그게 맞았다. (즉, P자루씩 몇 묶음 주문하고, 남은 나머지는 한 자루씩 주문하라는 뜻이었다...) 문제 이해하는 게 더 힘든 느낌이다
 
</details>

<details>
<summary> 9/14 <11일차> </summary>

### (브론즈 2) 1978번 소수 찾기
- **문제설명** : 주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램
- **느낀점** : 로직은 맞는데 1에 대한 예외처리를 따로 안해줘서 틀린거같아 아쉽다. 

### (브론즈 2) 2231번 분해합
- **문제설명** : 어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 
자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
- **느낀점** : 숫자 N이 주어지고 생성자 M을 구하는 문제여서 이걸 어떻게 구하지? 1부터 N까지 자릿수를 다 더해야하나? 이렇게 생각했다. 챗지피티의 힌트 '(N - N의 자리수 * 9)부터 체크하면 된다.'를 참고하여 문제를 풀었다. 그리고 자리수 구하는 짧은 코드도 이제 알게 되었다...

### (브론즈 2) 2798번 블랙잭 <나중에 다시 풀기>
- **문제설명** : N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.
- **느낀점** : 확률에 나오는 조합(nCr)의 경우의 수를 구하고, 그 수의 합이 M을 넘지 않아야한다고 해서 처음에는 멘붕이 왔다. 조합(중복 X, 순서 X)을 어떻게 코딩해야하는지 몰랐기때문이다. 이 문제는 나중에 다시 풀어봐야겠다. 
- **개념설명** : 조합의 경우 재귀함수로 코드를 작성한다. 다음 블로그에서 코드를 참고했다. https://hongchan.tistory.com/5 

</details>

<details>
<summary> 9/15 <12일차> </summary>

### (브론즈 2) 15829번 Hashing
- **문제설명** : 해시함수를 구현하여 입력받은 문자열을 해시값으로 출력한다.
- **느낀점** : 10일차까지는 그래도 10분안에 풀 수 있는 좀 쉬운 문제들이었는데 이제는 한시간이상은 고민하고 공부해야하는 문제들이 나온다. 수학적 특성(나머지 연산 분배의 법칙)을 적용해야해서 까다로웠던것같다. 
- **개념정리** : 해시함수의 경우 특정수를 거듭제곱하고 더하는 과정에서 long long 의 크기도 벗어나게 된다. 따라서 매 연산마다 mod 를 취해서 오버플로우를 방지해줘야한다. 

### (문제 등급) 문제 번호 문제 이름
- **문제설명** :
- **느낀점** :
- **개념정리** (선택사항) :

### (문제 등급) 문제 번호 문제 이름
- **문제설명** :
- **느낀점** :
- **개념정리** (선택사항) :

</details>