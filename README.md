# coding_in_RTU
everyday coding in RTU

---
<details>
<summary> 정리 템플릿 </summary>

### (문제 등급) 문제 번호 문제 이름
- **문제설명** :
- **느낀점** :
- **개념정리** (선택사항) :

</details>

---

<details>
<summary> 9/3 1일차 </summary>

### 브론즈 23881번 알고리즘 수업 - 선택 정렬 1
- **문제설명** : 선택정렬 수도코드를 제공하고 교환횟수를 체크하여 해당 교환횟수 번째에 교환되는 두개의 수를 출력하는 문제였다. 
- **느낀점** : 선택정렬에 대한 개념이 헷갈려 gif를 다시 보고 코드로 구현했다. 배열의 0번부터 확인하는 버전과 배열의 마지막번째부터 확인하는 버전 둘 다 구현해보았는데 반복문과 크기를 체크하는 것을 꼼꼼히 확인해야해서 어려웠다. 

- *selection sort* <br>
<img src = "https://github.com/whattheyeb/coding_in_RTU/blob/main/img/selection-600.gif" width = 300>
</details>

<details>
<summary> 9/4 <2일차> </summary>

### 브론즈 23882번 알고리즘 수업 - 선택 정렬 2
- **문제설명** : 이번 문제는 23881번 문제에서 약간 변형된 버전으로, 특정 교환 횟수 번째 이후의 정렬을 출력하는 문제였다. 
- **느낀점** : 이제 선택정렬을 구현하는 코드는 비교적 빠르게 작성할 수 있게 되었다. 하지만 for문 안에서 바로 답을 출력하려고 해서 첫번째 시도에서는 실패했었다. 선택정렬을 하는 for문 안에서는 결과를 바로 출력하기보다 flag 사용하거나 배열을 정렬하는 방식을 사용해야겠다.

### 브론즈 10871번 X보다 작은 수
- **문제설명** : 배열과 특정 수를 입력받고 배열 안의 숫자들 중 특정 수보다 작은 수들을 출력한다.
- **느낀점** : 이제 vector를 활용하여 배열을 입력받는 것을 습관들여야겠다.
- **개념정리** : vector 는 c++ 표준라이브러리 (#include <vector>) 에서 제공하는 동적 배열이다. push_back(value) : 맨 뒤에 값 추가, size() : 현재 원소 개수, empty() : 비었는지 확인, clear() : 모든 원소 제거, 초기 정의 : vector<int> v1(10);

### 브론즈 10952번 A + B - 5
- **문제설명** : 정수 a, b를 입력받고 a+b를 출력하는 코드를 작성하는 것, 단, a과 b 둘다 0일때는 아무것도 출력하지않고 종료한다.
- **느낀점** : while 문을 사용하면 a와 b 둘다 0일때에도 둘이 더한 값인 0을 출력하게된다. 그래서 do-while문을 사용했다.

</details>

<details>
<summary> 9/5 <3일차> </summary>

### (브론즈 3) 10818번 최소, 최대 
- **문제설명** : n개의 정수가 주어지고, 이 정수들의 값을 비교하여 최솟값과 최댓값을 구하는 프로그램을 작성
- **느낀점** : ez

### (브론즈 4) 25304번 영수증 
- **문제설명** : 총 금액과 물건의 종류에 대한 입력이 주어지며, 물건의 가격과 개수를 이용하여 실제 담은 금액과 영수증의 총 금액이 일치하는지 확인하는 프로그램을 작성
- **느낀점** : ez

### (브론즈 4) 15552번 빠른 A+B 
- **문제설명** : 정수 a, b를 굉장히 많이 입력받고, a+b를 출력하는 프로그램
- **느낀점** : 새로운 개념을 배웠다!!
- **개념설명** : cin.tie(NULL); 과 sync_with_stdio(false); 를 코드 앞에 작성한 후, endl 대신 \n 을 사용하면 된다. 다음 링크에 설명이 잘 되어있으니 참고해라 https://www.acmicpc.net/blog/view/128 

</details>

<details>
<summary> 9/6 <4일차> </summary>

### (브론즈 5) 10951번 A + B - 4
- **문제설명** : 두 정수 A + B를 입력받은 다음, A + B 를 출력한다.
- **느낀점** : 
- **개념정리** : EOF(End of File) 설정을 해줘야한다. 키보드 입력으로는 윈도우에서 Ctrl+Z 를 눌러 EOF를 발생시킨다. 그럼 반복문에서 조건을 어떻게 설정해야할까? 바로 그냥 while(cin >> a >> b) 이런식으로 조건식에 cin을 넣으면 된다. 

### (브론즈 3) 2562번 최댓값
- **문제설명** : 9개의 다른 자연수가 입력되며, 최댓값과 그 최댓값이 몇번째 수인지를 구하는 프로그램이다.
- **느낀점** : vector를 쓰니까 확실히 코드도 간결해지고 이해하기 쉬워졌다. 번외로 인덱스는 항상 현실 숫자 - 1 라는 것을 기억하자..

### (브론즈 3) 10810번 공넣기
- **문제설명** : 바구니 개수, 공을 넣는 회차 수가 주어진다. 그리고 각 회차마다 공을 넣을 바구니 번호의 범위 (두 개의 수)와 넣을 공의 번호가 주어진다. 공을 넣는 회차가 전부 끝난후, 바구니에 들어있는 공의 번호가 어떻게 되어있는지 출력한다. (단, 각 바구니에는 하나의 공만 들어있을 수 있다. 공이 이미 들어있는 경우 들어있는 공을 빼고 새로운 공을 넣는다)
- **느낀점** : 문제설명이 너무 길어서 읽는 데 힘들었지만 막상 푸는건 쉬웠다. for문 안에 또 다른 for문을 사용할때 조건식의 변수(i, j, k)를 다르게하고 통일시키자

</details>

<details>
<summary> 9/7 <5일차> </summary>

### (브론즈 2) 10813번 공바꾸기
- **문제설명** : 10810번과 기본적인 문제 토대는 같고, 바구니에 들어있는 공을 여러 회차동안 바꾼 후, 최종적으로 바구니에 있는 번호는 무엇인지 출력하는 프로그램을 작성한다
- **느낀점** : 10810번과 매우 비슷하고 swap함수를 사용하여 쉽게 해결했다.

### (브론즈 3) 5597번 과제 안 내신 분..?
- **문제설명** : 30명의 학생들 중 2명의 학생이 과제를 제출하지 않았다. 28개의 학생 번호가 입력으로 들어오면 그 중 제출하지않은 두 학생의 번호를 알아내어 출력한다.
- **느낀점** : for문 안에 변수를 선언하면 그 바깥에서는 초기화된다는 것을 몰랐다. 디버깅 출력 코드를 활용하여 알아내서 다행이다...

### (브론즈 2) 10811번 바구니 뒤집기
- **문제설명** : 10810, 10813번과 기본적인 문제 토대가 같다. 번호가 적힌 바구니를 여러 회차동안 역순으로 만든후, 최종적인 바구니 배열을 출력하는 프로그램을 작성한다.
- **느낀점** : 역순으로 만드는 코드에서 시간을 많이 썼다. 
- **개념정리** : 3번부터 5번 배열 원소를 뒤집어야한다. 그러면 바꾸는 작업이 2번 일어나게된다. (3번과 5번, 4번과 4번) -> swap을 활용한다면, 3부터 시작해서 (3 + 5) / 2 = 4까지, 2번만 반복한 후 끝나야하므로 num1부터 시작하여 num1 + num2 / 2 에서 멈춰야한다. 

### (브론즈 1) 1546번 평균
- **문제설명** : 기말고사 값들이 주어진다. 이 값 중 최댓값을 고르고 모든 점수를 각 과목의 점수 / 최댓값 * 100 을 진행한후 평균을 출력한다.
- **느낀점** : 처음에는 최댓값인 과목의 점수도 위와같이 진행하는지 모르고 있다가 질문게시판을 보고 깨닫게 되었다. 
- **개념정리** : c++ 에서는 int 끼리 나눗셈을 하면 소수점 이하의 숫자는 버려지기 때문에 casting을 해줘야한다. 이 문제를 풀 때에는 static_cast<type>(변수명) 이렇게 해줬다. (double 또는 float 로 선언해도 동일하다. ) 다음 티스토리를 보고 참고했다. https://code-studies.tistory.com/20 

</details>

<details>
<summary> 9/9 <6일차> </summary>

### (실버 5) 2941번 크로아티아 알파벳
- **문제설명** : 문제가 길어서 이미지로 첨부 <img src = "https://github.com/whattheyeb/coding_in_RTU/blob/main/img/bj2941.png" width = 400>
- **느낀점** : 문제는 풀긴했지만 if문남발에다가 복잡하게 작성한 것같아서 챗지피티에게 피드백을 받을 예정이다. 개인적으로 다음 인덱스로 바로 넘어가기위해 for문의 인덱스에 해당하는 i 를 사용한 방법은 마음에 든다. (핵심 아이디어는 “매칭되면 카운트 증가 후 인덱스 건너뛰기”)

### (브론즈 5) 27866번 문자와 문자열
- **문제설명** : 문자열과 숫자를 입력받고, 입력받은 숫자번째에 해당하는 문자를 출력한다. 
- **느낀점** : 기초문제여서 쉽게 풀었다.

### (브론즈 5) 9086번 문자열
- **문제설명** : 여러개의 문자열을 입력받고, 각 문자열의 첫번째 문자와 마지막 문자를 연속해서 출력한다. 
- **느낀점** : size() 함수를 사용하여 쉽게 풀 수 있다.

### (브론즈 5) 11654번 아스키 코드
- **문제설명** : 알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하는 프로그램을 작성하시오.
- **느낀점** : 몰라서 찾아봤다...
- **개념설명** : c++ 에서 문자를 아스키코드로 변환해서 하려면 다음과 같이 코드를 작성하면 된다고 한다. int ascii_value = static_cast<int>(input);

### (브론즈 4) 11720번 숫자의 합
- **문제설명** : 숫자개수와 띄어쓰기없이 쓰여진 숫자배열이 입력된다. 입력으로 주어진 숫자 N개의 합을 출력한다. 
- **느낀점** : 문자열과 관련된 문제라고 생각 안하고 있다가 공백없이 숫자 N개가 주어진다는 글을 보고 문자열로 숫자배열을 입력받고, 각 인덱스로 접근후 아스키코드값을 빼서  더해야겠다는 생각을 했다. 

### (브론즈 2) 10809번 알파벳 찾기
- **문제설명** : 문자열에서 알파벳이 처음 등장하는 위치를 찾아서 저장후 모든 알파벳에 대해 출력한다. 
- **느낀점** : 알파벳 배열을 잘못써서 틀렸다는 게 너무 웃김 (tuvwxyz...) 이런건 직접 찾아서 그냥 복사 붙여넣기하도록 하자. 

</details>

<details>
<summary> 9/10 <7일차> </summary>

### (브론즈 2) 2675번 문자열 반복
- **문제설명** : 테스트케이스 개수 N과 각 문자열 S와 반복횟수 R을 입력받는다. 문자열의 각 문자를 R번씩 반복하여 출력한다. 예시 : (입력) 3 ABC (출력) AAABBBCCC
- **느낀점** : ez

### (브론즈 2) 2908번 상수
- **문제설명** : 각 두개의 3자리 숫자를 입력받는다. 이 숫자를 뒤집은후 크기를 비교해 더 큰 숫자를 출력한다
- **느낀점** : vector의 push_back() 함수를 활용하고 싶어서 int 변수는 하나도 쓰지않았다. 챗지피티의 피드백을 읽고나니 불필요하게 저장공간을 썼음을 알 수 있었다.  

### (브론즈 2) 5622번 다이얼
- **문제설명** : 사진 참고 <br> <img src = "https://github.com/whattheyeb/coding_in_RTU/blob/main/img/bj5622.png" width = 450>
- **느낀점** : if문 폭탄으로 문제를 풀어서 조금 찝찝하다. 챗지피티의 코드를 봤는데 너무 충격적으로 잘짜서 충격임. 알파벳에 시간을 매핑해서 미리 정의한다는 개념을 사용한 것이 대박인거같다. 19줄을 3줄로 줄임

</details>

<details>
<summary> 9/11 <8일차> </summary>

### (브론즈 3) 11718번 그대로 출력하기
- **문제설명** : 입력 받은 문자열을 출력하는 프로그램을 작성하라 (문자열은 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져있다.)
- **느낀점** : 10951번과 비슷한 문제이다. 다만 공백이 포함되어있기때문에 cin이 아닌 getline을 사용해야한다는게 달랐다.
- **개념정리** : #include <string> 라이브러리의 getline(cin, 변수명) 함수를 사용하여 공백이 포함된 문자열 한줄을 입력받을 수 있다. 

### (브론즈 3) 2738번 행렬 덧셈
- **문제설명** : N*M 크기의 두 행렬이 주어졌을때, 두 행렬을 더하는 프로그램을 작성하라
- **느낀점** : 2차원배열을 오랜만에 써서 헷갈렸지만 문제자체가 어렵지않아 간단하게 이중 for문을 사용하여 풀 수 있었다.

</details>

<details>
<summary> 9/12 <9일차> </summary>

### (브론즈 5) 2744번 대소문자 바꾸기
- **문제설명** : 영어 소문자와 대문자로 이루어진 단어를 입력받은 뒤, 대문자는 소문자로, 소문자는 대문자로 바꾸어 출력하는 프로그램을 작성하시오.
- **느낀점** : 대소문자의 아스키코드 차이만큼 더해주고 빼는 로직을 사용하여서 쉬웠다.

### (브론즈 5) 15964번 이상한 기호
- **문제설명** : 입력받은 두 숫자에 대해 A＠B = (A+B)×(A-B) 를 계산한다
- **느낀점** : 그냥 long int 만 쓰면 해결되지않아서(100점 만점 중에 30점만 준다) 구글링을 통해 해결했다. 
- **개념정리** : 두 int 의 값이 커서 int 변수에 담을 수 없다면 long long int를 사용해야한다. long long int output = 1LL * (a + b) * (a - b);

### (브론즈 4) 31403번 A + B - C
- **문제설명** : A, B, C 를 각각 수와 문자열로 생각했을때, A + B - C를 출력하라
- **느낀점** : 테스트케이스에 한자리수만 있어서 단순히 char로 입력받고 '0'만큼 빼서 더하고 빼면 되겠다고 생각했는데 입력 부분에 a, b, c는 1에서 1000사이의 숫자라고 쓰여있는 것을 확인하게 되었다. 

### (브론즈 2) 8958번 OX 퀴즈
- **문제설명** : "OOXXOXXOOO"와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다.
"OOXXOXXOOO"의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다.
OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.
- **느낀점** : 이전 문제의 결과(O,X)에 대해 저장하는 배열 prev를 만들었다. 그런데 X 인 경우에 prev를 0으로 저장하지 않아서 이전 문제의 결과가 X인데도 불구하고 1로 저장되는 경우가 있었다. if 조건 설정과 예외처리를 꼼꼼히 봐야겠다. 로직은 백준 1316번과 비슷해서 쉽게 생각해낼 수 있었다. 

</details>

<details>
<summary> 9/13 <10일차> </summary>

### (브론즈 3) 10250번 ACM 호텔
- **문제설명** :  호텔의 층 수, 각 층의 방 수, 몇 번째 손님인지에 대한 입력이 들어오면, N 번째로 도착한 손님에게 배정될 방 번호를 계산하는 프로그램이다. (링크 참고 : https://www.acmicpc.net/problem/10250 )
- **느낀점** : 문제가 길어서 어려울 거라 생각했는데 2차원배열도 쓰지않고 쉽게 풀 수 있었다. 

### (브론즈 3) 4153번 직각삼각형
- **문제설명** : 주어진 세변의 길이로 삼각형이 직각인지 아닌지 구분하시오.
- **느낀점** : 빗변의 길이의 제곱과 나머지 두변의 길이의 제곱의 합이 같으면 직각삼각형이라는 정의를 그대로 코드에 적용하려고 했다. [1] 최댓값 구하기 [2] 길이의 제곱을 구해서 같은지 확인하는 함수 적용 [3] 출력 이 로직으로 작성했다. [1]파트에서 좀 더 효율적으로 코드를 짤 수 있을지 고민해봐야겠다. 

### (브론즈 3) 30802번 웰컴 키트
- **문제설명** : 참가자들에게 티셔츠와 펜을 줄 건데 얼만큼 준비해야하는지 구하는 문제
- **느낀점** : '펜을 P자루씩 최대 몇 묶음 주문할 수 있고, 그때 한 자루씩 몇 개 주문하는지' 이 말이 이해가 안가서 그냥 입출력 예시 보고 몫과 나머지인가 추측했는데 그게 맞았다. (즉, P자루씩 몇 묶음 주문하고, 남은 나머지는 한 자루씩 주문하라는 뜻이었다...) 문제 이해하는 게 더 힘든 느낌이다
 
</details>

<details>
<summary> 9/14 <11일차> </summary>

### (브론즈 2) 1978번 소수 찾기
- **문제설명** : 주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램
- **느낀점** : 로직은 맞는데 1에 대한 예외처리를 따로 안해줘서 틀린거같아 아쉽다. 

### (브론즈 2) 2231번 분해합
- **문제설명** : 어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 
자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
- **느낀점** : 숫자 N이 주어지고 생성자 M을 구하는 문제여서 이걸 어떻게 구하지? 1부터 N까지 자릿수를 다 더해야하나? 이렇게 생각했다. 챗지피티의 힌트 '(N - N의 자리수 * 9)부터 체크하면 된다.'를 참고하여 문제를 풀었다. 그리고 자리수 구하는 짧은 코드도 이제 알게 되었다...

### (브론즈 2) 2798번 블랙잭 <나중에 다시 풀기>
- **문제설명** : N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.
- **느낀점** : 확률에 나오는 조합(nCr)의 경우의 수를 구하고, 그 수의 합이 M을 넘지 않아야한다고 해서 처음에는 멘붕이 왔다. 조합(중복 X, 순서 X)을 어떻게 코딩해야하는지 몰랐기때문이다. 이 문제는 나중에 다시 풀어봐야겠다. 
- **개념설명** : 조합의 경우 재귀함수로 코드를 작성한다. 다음 블로그에서 코드를 참고했다. https://hongchan.tistory.com/5 

</details>

<details>
<summary> 9/15 <12일차> </summary>

### (브론즈 2) 15829번 Hashing
- **문제설명** : 해시함수를 구현하여 입력받은 문자열을 해시값으로 출력한다.
- **느낀점** : 10일차까지는 그래도 10분안에 풀 수 있는 좀 쉬운 문제들이었는데 이제는 한시간이상은 고민하고 공부해야하는 문제들이 나온다. 수학적 특성(나머지 연산 분배의 법칙)을 적용해야해서 까다로웠던것같다. 
- **개념정리** : 해시함수의 경우 특정수를 거듭제곱하고 더하는 과정에서 long long 의 크기도 벗어나게 된다. 따라서 매 연산마다 mod 를 취해서 오버플로우를 방지해줘야한다. 

### (브론즈 1) 1259번 팰린드롬수
- **문제설명** : 어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. 'radar', 'sees'는 팰린드롬이다. 수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다. 수들을 입력받고 그 수가 팰린드롬수인지 출력하자
- **느낀점** : 이렇게 여러개의 테스트케이스를 입력받는 문제의 경우 내가 flag가 되는 변수들(팰린드롬수인지 저장하는 bool 변수, 각 숫자의 자리수를 저장하는 벡터 등)을 초기화하지 않는 습관이 있다는 것을 인지하게되었다. 주의하자.. 
- **개념정리** : 벡터를 초기화하려면 v.clear() 함수를 호출하면 벡터에 포함된 모든 요소가 제거되고, 비워진다. 

### (브론즈 1) 2775번 부녀회장이 될테야
- **문제설명** : 거주조건이 "a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다"인 아파트의 k층 n호에는 몇 명이 살고 있는지 출력하라
- **느낀점** : 하드코딩해서 제한인 14에 맞춰서 미리 사람들 수를 모두 계산하여 배열에 저장해놓고, 입력받은 테스트케이스에 대해 출력하는 형식으로 코드를 짠 것이 조금 아쉽다. 

</details>

<details>
<summary> 9/16 <13일차> </summary>

### (브론즈 1) 2609번 최대공약수와 최소공배수
- **문제설명** : 두 수를 입력받고, 두 수의 최대공약수와 최소공배수를 구하여 출력한다
- **느낀점** : 두 수가 서로소일때를 고려하지않고 최대공약수 변수를 처음에 0으로 선언해서 런타임에러가 발생했다. (DivisionByZero) 모든 테스트케이스를 고려해봐야겠다. 

### (브론즈 1) 2869번 달팽이는 올라가고싶다 <다시 풀기>
- **문제설명** : 땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다. 달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다. 달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.
- **느낀점** : 처음에 나누는 로직을 생각했는데 예제 출력이랑 다르게 나와서 일일히 다 계산하는 while 문으로 했더니 이 경우는 또 시간이 너무 오래걸렸다. 결국 챗지피티의 힌트를 받아 문제를 해결했다. 다시 풀어야한다..

### (브론즈 1) 28702번 FizzBuzz
- **문제설명** : FizzBuzz 문제는 i = 1, 2, ... 에 대해 특정 규칙에 따라 문자열을 한 줄에 하나씩 출력하는 문제이다. FizzBuzz 문제에서 연속으로 출력된 세개의 문자열이 주어진다. 이 세 문자열 다음에 올 문자열을 구하고 출력해라
- **느낀점** : 입력되는 세개의 문자열 중 하나는 무조건 숫자라는 점을 활용해 Fizz, Buzz, FizzBuzz 가 아닌 문자열이 입력되면 이 문자열의 인덱스와 문자열(숫자)을 vector에 저장한 후 다음에 올 문자열을 구하는 로직으로 구현하였다. 좀 잔머리로 푼거같긴하다...
- **개념정리** : <string> 라이브러리의 stoi함수를 사용하면 string을 int로 쉽게 변환할 수 있다. int 변수 = stoi(string 변수);

</details>

<details>
<summary> 9/17 <14일차> </summary>

### (실버 5) 1436번 영화감독 숌
- **문제설명** : 제일 작은 종말의 수는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 이다. 따라서, 숌은 첫 번째 영화의 제목은 "세상의 종말 666", 두 번째 영화의 제목은 "세상의 종말 1666"와 같이 이름을 지을 것이다. 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 수) 와 같다. 숌이 만든 N번째 영화의 제목에 들어간 수를 출력하는 프로그램을 작성하시오
- **느낀점** : 처음에는 666이 들어가는 수들의 규칙을 찾으려했는데 도저히 못찾아서 챗지피티의 힌트를 얻어서 해결했다. (모든 수를 체크하면서 666이 들어간 수를 찾는 방식)
- **개념정리** : <string>헤더에 int를 string으로 바꾸는 to_string() 함수와 string에 원하는 문자열이 어디 인덱스에 들어있는지 찾아주는 find() 함수

### (브론즈 1) 14626번 ISBN
- **문제설명** : ISBN에는 13자리의 숫자로 표시된다. 그중 마지막 숫자는 체크기호로 정확성여부를 점검하는 숫자이다. 이 체크기호는 일련번호의 앞에서부터 각 자리마다 가중치 1, 3, 1, 3…. 를 곱한 것을 모두 더하고, 그 값을 10으로 나눈 나머지가 0이 되도록 만드는 숫자 m을 사용한다.
손상된 자리의 숫자를 찾아내는 프로그램을 작성하자
- **느낀점** : 문해력이 낮아진건지 문제자체를 이해하고 식을 생각하는데 오래 걸렸다. 그리고 마지막에는 좀 하드하게 3의 나머지들과 매칭하는 식으로 했다가 for문을 돌며 계산하는 방식으로 고쳤다. 코딩테스트 풀려면 문제를 읽고 이해하는것도 꽤나 중요해보인다....

### (실버 5) 7568번 덩치
- **문제설명** : 키도 더 크고, 몸무게도 더 나가는 사람을 덩치가 더 크다라고 말한다고 하자, 사람들의 키와 몸무게를 입력받고 사람의 덩치 등수를 구해서 출력한다. 
- **느낀점** : 간단한 문제를 너무 어렵게생각했다. 각 사람의 경우를 따져서 더 큰 덩치의 사람명수를 저장하고, 사람명수가 없는 사람부터 높은 등수를 주는 방식으로 코드를 작성했었다. 하지만 그럴 필요없이, 덩치를 비교할때부터 자신보다 덩치가 큰 사람이 있다면 등수를 하나씩 낮추면 되는 일이었다. 어차피 각각 사람들에 대해 rank를 체크하는 것이기 때문에 점수가 같은 사람들을 따로 체크할 필요가 없다. 

</details>

<details>
<summary> 9/18 <15일차> </summary>

### (실버 5) 1181번 단어 정렬
- **문제설명** : 알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.
    - 길이가 짧은 것부터
    - 길이가 같으면 사전 순으로
단, 중복된 단어는 하나만 남기고 제거해야 한다.
- **느낀점** : 쉬울줄 알았는데 막상 풀어보니 두가지때문에 어려웠다. 첫번째는 길이가 같을때 각 자리의 아스키코드값을 비교한 후 인덱스를 저장해야한다는 것(compare함수를 쓰지않고 하려니 어려웠다)과 두번째는 중복된 단어는 하나만 남기고 삭제해야한다는 것이었다.  
- **개념정리** : <string> 헤더의 compare 함수는 str1.compare(str2) 로 예시를 들어보면 str1과 str2 가 같을때는 0, str1이 str2보다 클때는 양의 정수, str2이 str1보다 클때는 음의 정수를 return한다.
<algorithm> 헤더의 unique함수는 unique(word.begin(), word.end()) word 배열을 돌면서 겹치는 수를 찾아준다. erase() 함수는 범위를 설정하거나 특정 인덱스 지정하여 벡터를 지울 수 있는 함수이다. 

### (실버 5) 2751번 수 정렬하기 2
- **문제설명** : N개의 수가 주어졌을때, 이를 오름차순으로 정렬하는 프로그램을 작성해라
- **느낀점** : 그냥 편하게 풀고싶어서 algorithm 헤더의 sort 함수를 사용했다. 퀵소트나 머지소트 코드 공부를 좀 시작해야겠다.

### (Easy) Two sum
- **문제설명** : 숫자배열과 target이 주어졌을때, 숫자배열 중 2개 숫자의 조합이 target과 일치한다. 이 2개 숫자의 인덱스를 찾아 vector로 return한다.
- **느낀점** : 내가 푼 방식은 실행시간이 오래걸렸다. 그 이유는 내가 따로 vector 변수에 저장하고 마지막에 return 하려고해서였다. 그럴필요없이 찾는 즉시 해당 배열을 return하면된다.

</details>

<details>
<summary> 9/19 <16일차> </summary>

### (실버 4) 1920번 수 찾기
- **문제설명** : N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.
- **느낀점** : 처음에 시도할때는 linear search (정렬되지않은 상태로 for 문 사용하여 찾기) 로 코드를 작성했다. 당연히, 시간초과가 떴다. 그래서 두번째 시도때는 먼저 배열을 정렬하고, binary search 를 사용하여 작성하고 성공했다. 
- **개념정리** : https://www.geeksforgeeks.org/dsa/binary-search/ 

### (실버 5) 11650번 좌표 정렬하기 <다시 풀기>
- **문제설명** : 2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오
- **느낀점** : 1차원 배열에 대해 정렬하는건 할 수 있는데 2차원 배열에 대해서는 어떻게 풀지 감도 안왔다. 챗지피티의 힌트를 참고하여 먼저 구조체를 만든 후, sort 함수를 사용하여 x 좌표가 같으면 y좌표가 증가하는 함수를 추가하는 방식으로 풀었다. sort함수에 대해 더 알게되었다.
- **개념정리** : sort함수는 세번째 파라미터에 custom comparator를 추가할 수 있다. 
```
bool comp(Point& a, Point& b){
    if(a.x == b.x) return a.y < b.y;
    return a.x < b.x; 
}

int main(){
    sort(points.begin(), points.end(), comp);
}
```

### (easy) Roman to integer
- **문제설명** : 로마숫자로 이루어진 문자열을 입력받아서 아라비아숫자로 변환하는 프로그램을 작성하라 
- **느낀점** : 문제를 주의깊게 안읽고 그냥 일대일대응으로 변환하는 방식으로 풀어서 처음 시도때는 틀렸다. 다시 읽어보니 예외가 있었다.. 그래서 i번째에 검사할때 i + 1번째 문자도 함께 검사하여 만약 한세트인 로마숫자라면 i를 증가시켰다. 


</details>

<details>
<summary> 9/20 <17일차> </summary>

### (실버 5) 25206 너의 평점은
- **문제설명** : 치훈이의 전공평점을 계산해주는 프로그램을 작성해보자. 전공평점은 전공과목별 (학점 × 과목평점)의 합을 학점의 총합으로 나눈 값이다. P/F 과목의 경우 등급이 P또는 F로 표시되는데, 등급이 P인 과목은 계산에서 제외해야 한다.
- **느낀점** : struct를 정의하여 각 과목당 학점과 등급을 저장한 후 전공평점을 구했다. 하지만 아래의 코드처럼 F를 따로 조건을 안빼고 P와 함께 처리해서 틀렸다. F 등급인 경우, 0점으로 계산되지만 학점평균에는 들어가기때문이다.


```
if(s[i].rating != "P"){
            sum += toCredit(s[i].rating) * s[i].credit;
            creditSum += s[i].credit;
        }else if(s[i].rating == "F"){
            sum += 0;
            creditSum += s[i].credit;
}
```

### (브론즈 3) 2566번 최댓값
- **문제설명** :  9×9 격자판에 쓰여진 81개의 자연수 또는 0이 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 행 몇 열에 위치한 수인지 구하는 프로그램을 작성하시오.
- **느낀점** : 81이라는 상수로 정해져있어서 2차원배열을 사용하여 쉽게 풀었다. 

### (브론즈 1) 10798번 세로읽기
- **문제설명** : 한 줄의 단어는 글자들을 빈칸 없이 연속으로 나열해서 최대 15개의 글자들로 이루어진다. 또한 만들어진 다섯 개의 단어들의 글자 개수는 서로 다를 수 있다. 심심해진 영석이는 칠판에 만들어진 다섯 개의 단어를 세로로 읽으려 한다. 세로로 읽을 때, 각 단어의 첫 번째 글자들을 위에서 아래로 세로로 읽는다. 다음에 두 번째 글자들을 세로로 읽는다. 이런 식으로 왼쪽에서 오른쪽으로 한 자리씩 이동 하면서 동일한 자리의 글자들을 세로로 읽어 나간다. 영석이가 읽는 방식으로 글자들을 출력하는 프로그램을 작성하라
- **느낀점** : 인덱스가 출력할 문자열의 길이를 벗어날때를 생각하지않고 처리를 안해줘서 틀렸다. 무지성 제출을 자제해보자 ...

</details>

<details>
<summary> 9/21 <18일차> </summary>

### (실버 5) 1316번 그룹 단어 체커 <다시 풀기>
- **문제설명** : 그룹 단어란 단어에 존재하는 모든 문자에 대해서, 각 문자가 연속해서 나타나는 경우만을 말한다. 예를 들면, ccazzzzbb는 c, a, z, b가 모두 연속해서 나타나고, kin도 k, i, n이 연속해서 나타나기 때문에 그룹 단어이지만, aabbbccb는 b가 떨어져서 나타나기 때문에 그룹 단어가 아니다. 단어 N개를 입력으로 받아 그룹 단어의 개수를 출력하는 프로그램을 작성하시오.
- **느낀점** : 약 일주일전에 이 문제를 마주했을때는 어떻게 풀지도 몰랐는데 그래도 이번에는 약간의 힌트(?)와 함께 푸는 나의 모습을 보며 좀 뿌듯했다. 하지만 다음에 다시 풀어봐야한다...

### (실버 5) 2563번 색종이
- **문제설명** : 가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.
- **느낀점** : 나는 문제를 너무 어렵게(인간처럼) 풀려고 하는것같다. 처음에 문제를 읽었을때 "색종이끼리 겹치는 부분을 어떻게 구하지?" 라는 생각에 사로잡혀서 코드 작성을 시작조차 하지못했다. 하지만 챗지피티의 힌트..(겹치는 부분을 계산할 필요없이 도화지를 100*100 배열로 두고 색종이의 길이에 해당하는 배열을 한칸씩 색칠한다고 생각해라)를 보고 놀랐다...

</details>

<details>
<summary> 9/22 <19일차> </summary>

### (브론즈 1) 2869번 달팽이는 올라가고싶다 - 13일차 복습
- **느낀점** : 기억을 되살리는동안은 버벅였지만 중요한 포인트들(나머지가 있는경우 올림하기, 마지막 날에 올라가는 길이는 미리 빼주기)을 기억해서 풀 수 있었다. 

### (실버 5) 11650번 좌표 정렬하기 - 16일차 복습
- **느낀점** : 벡터에 입력할때 벡터 크기를 정의해주지않으면 오류가 걸리는것같다. 다시 풀때 조금 헷갈려서 깃허브 리드미를 참고하여 풀었다.

### (실버 5) 1193번 분수찾기 (다시 풀기)
- **문제설명** : 이와 같이 나열된 분수들을 1/1 → 1/2 → 2/1 → 3/1 → 2/2 → … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자. X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.
- **느낀점** : 사실 이 문제도 규칙을 못찾아서 챗지피티의 힌트를 받아 풀었다. 사람들이 올린 질문들 보니까 힌트보지말고 스스로 찾으라고 하던데 쩝.. 그래도 충분히 고민했다고 생각한다. (힌트는 다음과 같았다 1. 몇번째 그룹인지 찾기 2. 그룹안에서 몇번째인지 계산하기 3. 홀수인지 짝수인지에 따라 증감방향이 달라짐)

</details>

<details>
<summary> 9/23 <20일차> </summary>

### (실버 4) 2164번 카드 2
- **문제설명** : N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.
이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.
- **느낀점** : 나름 수학적 규칙을 찾았다고 생각했는데 틀린 규칙이었다. 다음에는 queue를 활용해서 푸는 방식을 생각해봐야겠다.

### (브론즈 3) 5086번 배수와 약수
- **문제설명** : 두 수가 주어졌을 때, 다음 3가지 중 어떤 관계인지 구하는 프로그램을 작성하시오.
첫 번째 숫자가 두 번째 숫자의 약수이다. -> "factor" 출력
첫 번째 숫자가 두 번째 숫자의 배수이다. -> "multiple" 출력
첫 번째 숫자가 두 번째 숫자의 약수와 배수 모두 아니다. -> "neither" 출력
- **느낀점** : 간단하게 풀 수 있었던 문제다.

### (브론즈 3) 2501번 약수 구하기
- **문제설명** : 두 개의 자연수 N과 K가 주어졌을 때, N의 약수들 중 K번째로 작은 수를 출력하는 프로그램을 작성하시오.
- **느낀점** : 자연수 N의 약수를 구하면 자연수 N 또한 포함된다는 사실을 까먹었다. 그래서 처음 시도때 틀렸다. 예를 들어 6의 약수 중 4번째로 작은 수는 6이기 때문이다.

</details>

<details>
<summary> 9/24 <21일차> </summary>

### (브론즈 1) 9506번 약수들의 합
- **문제설명** : 어떤 숫자 n이 자신을 제외한 모든 약수들의 합과 같으면, 그 수를 완전수라고 한다. 예를 들어 6은 6 = 1 + 2 + 3 으로 완전수이다.
n이 완전수인지 아닌지 판단해주는 프로그램을 작성하라
- **느낀점** : 약수를 판정하는 로직은 알고있었기에 총합 변수를 지정해두고 약수들을 모두 더한 값을 저장한 후, 완전수인지 아닌지 판단하는 식으로 쉽게 풀 수 있었다.

### (브론즈 2) 2581번 소수
- **문제설명** : 자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.
- **느낀점** : 문제 접근은 맞았는데 M과 N 사이에 소수가 없는 경우를 처리해야한다는 글을 안읽고 풀어서 그 부분에서 틀렸다. 소수의 개수를 카운트하는 cnt 변수를 추가하여 cnt 변수가 0이라면 -1을 출력하도록 수정했다.

</details>

<details>
<summary> 9/25 <22일차> </summary>

### (브론즈 2) 2745번 진법 변환
- **문제설명** : B진법 수 N이 주어진다. 이 수를 10진법으로 바꿔 출력하는 프로그램을 작성하시오.
- **느낀점** : 16진법을 2진수로 변환하는 문제는 논리설계 시간에 많이 풀어봤는데 36진법을 10진법으로 변환하는 문제는 처음이여서 어떻게 풀지 몰랐다. 찾아보니 각 자리수에 N진법의 N을 제곱한 후 다 더해주면 10진법 수로 변환된다고 나왔다. 이 계산법을 똑같이 로직에 적용하여 풀었다. 

### (브론즈 5) 27323번 직사각형
- **문제설명** : 정수 A, B 가 주어진다. 세로 길이가 A cm, 가로 길이가 B cm 인 아래와 같은 직사각형의 넓이를 cm2 단위로 구하시오.
- **느낀점** : 손풀기 문제로 1분만에 풀었다

### (브론즈 3) 1085번 직사각형에서 탈출
- **문제설명** : 한수는 지금 (x, y)에 있다. 직사각형은 각 변이 좌표축에 평행하고, 왼쪽 아래 꼭짓점은 (0, 0), 오른쪽 위 꼭짓점은 (w, h)에 있다. 직사각형의 경계선까지 가는 거리의 최솟값을 구하는 프로그램을 작성하시오.
- **느낀점** : 처음에는 한수의 점에서 각 변까지의 거리들을 다 비교한 후, 최솟값을 구하는 로직으로 생각했는데 천천히 다시 생각해보니 그럴 필요가 없었다! 각 변까지의 거리를 배열에 저장한 후, 최솟값을 구하는 식으로 코드를 작성하면 더 쉬웠다.

### (브론즈 3) 3009번 네 번째 점
- **문제설명** : 세 점이 주어졌을 때, 축에 평행한 직사각형을 만들기 위해서 필요한 네 번째 점을 찾는 프로그램을 작성하시오.
- **느낀점** : 약간 노가다 if문으로 문제를 풀어서 찝찝하다. 

</details>

<details>
<summary> 9/26 <23일차> </summary>

### (브론즈 3) 15894번 수학은 체육과목입니다.
- **문제설명** : "한 변의 길이가 1인 정사각형을 아래 그림과 같이 겹치지 않게 빈틈없이 계속 붙여 나간다. 가장 아랫부분의 정사각형이 n개가 되었을 때, 실선으로 이루어진 도형의 둘레의 길이를 구하시오." 가장 아랫부분의 정사각형 개수가 주어지면 그에 해당하는 답을 출력하는 프로그램을 만들어 형석이를 도와주자!
- **느낀점** : 복잡한 수학 규칙이 있을줄 알았는데 식을 정리하고 나니 answer = 4n 이라는 간단한 식이 나와서 당황했다.

### (브론즈 4) 10101번 삼각형 외우기
- **문제설명** : 창영이는 삼각형의 종류를 잘 구분하지 못한다. 따라서 프로그램을 이용해 이를 외우려고 한다.
삼각형의 세 각을 입력받은 다음,
세 각의 크기가 모두 60이면, Equilateral
세 각의 합이 180이고, 두 각이 같은 경우에는 Isosceles
세 각의 합이 180이고, 같은 각이 없는 경우에는 Scalene
세 각의 합이 180이 아닌 경우에는 Error 를 출력하는 프로그램을 작성하시오.
- **느낀점** : bool 플래그를 사용하여 세각의 크기가 모두 60인 경우를 처리하려고 했는데 잘못 코드를 작성해서 그냥 if문으로 처리했다.

### (브론즈 3) 5073번 삼각형과 세 변
- **문제설명** : 삼각형의 세 변의 길이가 주어질 때 변의 길이에 따라 다음과 같이 정의한다.
Equilateral :  세 변의 길이가 모두 같은 경우
Isosceles : 두 변의 길이만 같은 경우
Scalene : 세 변의 길이가 모두 다른 경우
단 주어진 세 변의 길이가 삼각형의 조건을 만족하지 못하는 경우에는 "Invalid" 를 출력한다. 예를 들어 6, 3, 2가 이 경우에 해당한다. 가장 긴 변의 길이보다 나머지 두 변의 길이의 합이 길지 않으면 삼각형의 조건을 만족하지 못한다. 세 변의 길이가 주어질 때 위 정의에 따른 결과를 출력하시오.
- **느낀점** : 앞서 푼 10101번 문제와 매우 비슷해서 비슷한 로직으로 풀었다. 다른 점은 가장 긴 변의 길이의 인덱스를 따로 빼고 나머지 인덱스들을 벡터에 넣어 저장했다는 점이다. 가장 긴변의 길이 외에 나머지 길이의 인덱스들을 저장한 이유는 두 변의 길이가 같은 경우를 더 짧은 조건문으로 바꾸고싶어서이다. 
- **개념정리** : vector의 첫 원소와 마지막 원소는 각각 v.front(), v.back() 함수를 사용한다.  


</details>

<details>
<summary> 9/27 <24일차> </summary>

### (브론즈 3) 9063번 대지
- **문제설명** : 임씨의 이름이 새겨진 옥구슬의 위치 N 개가 주어질 때에, 임씨에게 돌아갈 대지의 넓이를 계산하는 프로그램을 작성하시오. 
- **느낀점** : 문제가 거의 소설마냥 길어서 어려울까 겁먹었지만 핵심적인 풀이는 간단했다. 좌표 여러개를 입력받고 x좌표와 y좌표의 최댓값, 최솟값를 구한 후, 최댓값과 최솟값의 차이를 곱하는 로직으로 코드를 작성했다.

### (브론즈 3) 14215번 세 막대
- **문제설명** : a, b, c가 주어졌을 때, 만들 수 있는 가장 큰 둘레를 구하는 프로그램을 작성하시오. 
- **느낀점** : 나는 너무 어렵게 이 문제를 풀려고 했었다.. 인덱스에 초점을 맞추고 어느 막대 길이가 같은지를 따졌는데 그럴 필요없이 막대의 길이들을 입력받은 후 크기대로 정렬 후, 계산하면 됐다.

</details>

<details>
<summary> 9/28 <25일차> </summary>

### (브론즈 1) 11005번 진법 변환 2
- **문제설명** : 10진법 수 N이 주어진다. 이 수를 B진법으로 바꿔 출력하는 프로그램을 작성하시오. 10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.
A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35
- **느낀점** : 10진수를 N진수로 바꾸는 방법이 헷갈려서 아래의 티스토리를 참고하면서 풀었다. 10진수가 0이 될때까지 N으로 나누면서 나눌때마다의 나머지를 벡터에 저장하는 방식으로 코드를 작성했다. 또한 나머지가 9를 넘어가는 숫자라면 알파벳으로 변환해주어야하기 때문에 string에 저장한 알파벳 배열과 매칭시켜 변환하는 방식으로 코드를 작성했다.
- **개념정리** : 진법변환의 원리 https://midoriprogramming.tistory.com/16 

</details>

<details>
<summary> 9/29 <26일차> </summary>

### (브론즈 3) 2720번 세탁소 사장 동혁
- **문제설명** : 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 거스름돈 C를 나타내는 정수 하나로 이루어져 있다. C의 단위는 센트이다. 각 테스트케이스에 대해 필요한 쿼터의 개수, 다임의 개수, 니켈의 개수, 페니의 개수를 공백으로 구분하여 출력한다.
- **느낀점** : 그리디 알고리즘을 활용하여 가장 큰 동전부터 나누는 방식으로 코드를 작성했다. 하루전에 강의로 들었던 내용이 나와서 쉽게 풀 수 있었다.

### (브론즈 3) 2903번 중앙 이동 알고리즘
- **문제설명** : 정사각형의 각 변의 중앙에 점을 하나 추가한다. 정사각형의 중심에 점을 하나 추가한다. 과정을 N번 거친 후 점 몇 개를 저장해야 하는지 구하는 프로그램을 작성하시오.
- **느낀점** : 정사각형 위에 생겨나는 점의 개수 규칙을 살펴보면 (이전 정사각형의 한변 위에 있는 점의 개수 * 2 - 1) 의 제곱임을 알 수 있다. 따라서 한 변 위에 있는 점의 개수를 먼저 배열로 만든 후, 입력받은 N에 대해 따로 제곱을 계산하여 제곱하는 방식으로 코드를 작성했다. 

### (브론즈 2) 2292번 벌집 <다시풀기>
- **문제설명** : 입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.
- **느낀점** : 생각보다 규칙은 빠르게 찾았지만 방의 개수를 세는 부분에서 while 문의 조건문을 잘못 설정해서 여러번 틀렸다. 나중에 다시 풀어보자 너무 아쉽다.

</details>

<details>
<summary> 9/30 <27일차> </summary>

### (브론즈 2) 2750번 수 정렬하기
- **문제설명** : N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
- **느낀점** : 최대 1000개의 수를 정렬해야하기 때문에 시간복잡도가 O(nlogn)인 merge sorting algorithm 을 적용하여 문제를 풀었다.
- **개념정리** : merge sort 코드는 다음 사이트를 보고 작성했다. https://www.geeksforgeeks.org/dsa/merge-sort/ 

### (실버 4) 11399번 ATM
- **문제설명** : 첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000), 첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.
- **느낀점** : 알고리즘 라이브러리의 sort 함수를 사용하여 먼저 인출하는 시간이 적은 순서대로 정렬한후 각 사람당 누적 시간을 따로 벡터에 저장했다. 그리고 누적 시간을 모두 더한 값을 출력하는 방식으로 코드를 작성했다. 정렬만 하면 되는 문제라 쉽게 풀었다.

### (실버 5) 1427번 소트인사이드
- **문제설명** : 배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자. 첫째 줄에 정렬하려고 하는 수 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.
- **느낀점** : 4321을 입력받으면 1234로 바꿔서 출력해야하기 때문에 처음에 입력받을때부터 string으로 입력받았다. 그리고 각 자리마다 '0' 아스키값을 빼 int 벡터에 저장했다. 그리고 정렬한 후 출력하는 방식으로 코드를 작성했다. 생각해보니 char 그대로 sorting하면 굳이 int벡터에 저장할 필요가 없을거같기도 하다. 다시 한번 풀어봐야겠다. -> 그냥 char 그대로 sorting하니까 아스키코드값으로 저장이 되어서 마지막에 출력할때 0에 해당하는 아스키코드값인 48을 빼는 방식으로 코드를 작성할 수도 있다!!!

</details>

<details>
<summary> 10/1 <28일차> </summary>

### (브론즈 5) 24262번 알고리즘 수업 - 알고리즘의 수행 시간 1
- **문제설명** : 입력의 크기 n이 주어지면 MenOfPassion 알고리즘 수행 시간을 예제 출력과 같은 방식으로 출력해보자. 첫째 줄에 코드1 의 수행 횟수를 출력한다. 둘째 줄에 코드1의 수행 횟수를 다항식으로 나타내었을 때, 최고차항의 차수를 출력한다. 단, 다항식으로 나타낼 수 없거나 최고차항의 차수가 3보다 크면 4를 출력한다.
- **느낀점** : 처음에는 수행횟수를 따로 세서 출력해야하나? 그리고 다항식으로 나타낸다는건 어떤거지? 하며 혼란스러웠는데 질문게시판의 한 글을 보고 깨달았다. 주어진 알고리즘은 n이 어떤 숫자이든간에 한번 실행되는 O(1)의 시간복잡도를 가진 알고리즘이므로 항상 1과 0을 출력한다.

### (브론즈 4) 24263번 알고리즘 수업 - 알고리즘의 수행 시간 2
- **문제설명** : 24262번 문제와 동일하며 menofpassion 알고리즘 코드 부분만 다르다.
- **느낀점** : 24262번 문제도 그렇고 이 문제들은 코딩을 어떻게 하냐보다 반복문에 따라 시간복잡도가 어떻게 달라지는지 아는지 물어보는 것같다.

### (브론즈 3) 24264번 알고리즘 수업 - 알고리즘의 수행 시간 3
- **문제설명** : 24262번 문제와 동일하며 menofpassion 알고리즘 코드 부분만 다르다.
- **느낀점** : int의 범위를 벗어난 input이여서 long long int로 선언했더니 맞았다. int 범위가 애매하면 long long int로 하자

</details>

<details>
<summary> 10/2 <29일차> </summary>

### (브론즈 3) 24265번 알고리즘 수업 - 알고리즘의 수행 시간 4
- **문제설명** : 24262번 문제와 동일하며 menofpassion 알고리즘 코드 부분만 다르다.
- **느낀점** : menofpassion 알고리즘을 직접 실행하여 수행횟수를 카운트하는 방식으로 코드를 작성했더니 n이 500,000일때는 2~3초를 초과했다. 그래서 규칙을 찾아서 계산하는 방식으로 코드를 수정했다. 

### (브론즈 3) 24266번 알고리즘 수업 - 알고리즘의 수행 시간 5
- **문제설명** : 24262번 문제와 동일하며 menofpassion 알고리즘 코드 부분만 다르다.
- **느낀점** : 이 문제는 시간복잡도를 다항식으로 표현했을때 n^3 인 경우를 표현하고자해서 앞서 푼 문제와 똑같이 n을 세제곱한 것을 출력하는 방식으로 문제를 풀었다.

### (브론즈 3) 24267번 알고리즘 수업 - 알고리즘의 수행 시간 6
- **문제설명** : 24262번 문제와 동일하며 menofpassion 알고리즘 코드 부분만 다르다.
- **느낀점** : 먼저 menofpassion 반복문을 실행하고 규칙을 발견한 후 해당 규칙을 적용시켜서 출력하는 방식으로 코드를 작성했다. 

</details>

<details>
<summary> 10/3 <30일차!!!> </summary>

### (실버 5) 24313번 알고리즘 수업 - 점근적 표기 1
- **문제설명** : 알고리즘의 소요 시간을 나타내는 O-표기법(빅-오)을 다음과 같이 정의하자. 
```
O(g(n)) = {f(n) | 모든 n ≥ n0에 대하여 f(n) ≤ c × g(n)인 양의 상수 c와 n0가 존재한다}
```
함수 f(n) = a1n + a0, 양의 정수 c, n0가 주어질 경우 O(n) 정의를 만족하는지 알아보자.

- **느낀점** : c >= a0 이 조건을 추가하지 않아서 첫 시도에는 틀렸다. 이 조건을 왜 추가해야하는지에 대해 의문이 들었는데 천천히 생각해보니까 f(n) 이 4n - 2이고 c * g(n) 이 2n이라면 f(n) ≤ c × g(n) 이 식에 대해서는 만족하지만 모든 n에 대해서는 만족하지 않는다.

### (브론즈 2) 2587번 대표값2
- **문제설명** : 다섯 개의 자연수가 주어질 때 이들의 평균과 중앙값을 구하는 프로그램을 작성하시오.
- **느낀점** : 벡터로 입력받고 입력받을때마다 sum 변수에 더하고 5로 나눈값을 출력하는 방식으로 풀었다. 입력개수가 5로 정해져있어서 기본문제로 느껴졌다.

### (브론즈 2) 25305번 커트라인
- **문제설명** : 2022 연세대학교 미래캠퍼스 슬기로운 코딩생활에 
$N$명의 학생들이 응시했다.이들 중 점수가 가장 높은 $k$명은 상을 받을 것이다. 이 때, 상을 받는 커트라인이 몇 점인지 구하라.
커트라인이란 상을 받는 사람들 중 점수가 가장 가장 낮은 사람의 점수를 말한다.
- **느낀점** : 선택정렬 코드를 잘못 써놓고 다른데서 뭐가 잘못됐는지를 찾고있었다. 선택정렬에서 swap하는건 각 인덱스마다 최대한번이다...

</details>

<details>
<summary> 10/4 <31일차> </summary>

### (브론즈 1) 10989번 수 정렬하기 3 <다시 풀기>
- **문제설명** : N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
- **느낀점** : 계수정렬(counting sort)을 이용해서 처음 문제를 풀었는데 이렇게 메모리를 절약하면서 빠르게 정렬할 수 있다는것에 놀랐다. counting sort 공부하고 다시 풀어봐야겠다.

### (실버 5) 11651번 좌표 정렬하기 2
- **문제설명** : 2차원 평면 위의 점 N개가 주어진다. 좌표를 y좌표가 증가하는 순으로, y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.
- **느낀점** : 좌표정렬하기 1번이랑 똑같고 조건만 다르게 설정하면 돼서 쉽게 풀 수 있었다.

</details>

<details>
<summary> 10/5 <32일차> </summary>

### (브론즈 2) 19532번 수학은 비대면강의입니다
- **문제설명** : 다음 연립방정식에서 x 와 y의 값을 계산하시오.
```
ax + by = c
dx + ey = f
```
- **느낀점** : 양변에 d, a를 곱해서 x의 계수를 같게 한후 두 식을 빼는 형식으로 풀었다. 처음에는 y의 값을 구한후, (c - by) / a 이 방식으로 x를 구하려고 했는데 a가 0일수도 있기때문에 DivisionBy0 에러가 떴다. 그래서 양변에 d, a를 곱해서 푼것처럼 b, e를 곱해서 풀었더니 해결되었다.

### (실버 3) 1018번 체스판 다시 칠하기 <다시 풀기>
- **문제설명** : 지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.

체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.

보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.
- **느낀점** : 체스판의 각 칸의 색을 체크하는 알고리즘은 생각해냈는데 8*8 크기의 체스판만큼에서 최소 개수를 구하는 알고리즘에서 막혀서 챗지피티의 힌트를 받았다. 다시 풀어보자...

</details>

<details>
<summary> 10/6 <33일차> </summary>

### (실버 2) 18870번 좌표 압축
- **문제설명** : 수직선 위에 N개의 좌표 X1, X2, ..., XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다. Xi를 좌표 압축한 결과 X'i의 값은 Xi > Xj를 만족하는 서로 다른 좌표 Xj의 개수와 같아야 한다. X1, X2, ..., XN에 좌표 압축을 적용한 결과 X'1, X'2, ..., X'N를 출력해보자.
- **느낀점** : 먼저 입력받은 좌표 배열과 똑같은 배열을 만든다. 그리고 복사한 배열을 오름차순으로 sorting하고, 중복된 값은 삭제한다. 입력받은 좌표 배열 원소 하나하나씩 반복문을 돌면서 binarysearch를 이용하여 정렬된 배열 중 어디 인덱스에 위치해있는지 찾는다. 인덱스가 곧 자신보다 작은 좌표의 개수이기 때문이다. 이런 로직으로 작성했는데 처음에는 binarysearch를 사용하지 않아서 시간초과가 나왔다. 

</details>

<details>
<summary> 10/7 <34일차> </summary>

</details>