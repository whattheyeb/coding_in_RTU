# coding_in_RTU
everyday coding in RTU

---
<details>
<summary> 정리 템플릿 </summary>

### (문제 등급) 문제 번호 문제 이름
- **문제설명** :
- **느낀점** :
- **개념정리** (선택사항) :

</details>

---

<details>
<summary> 9/3 1일차 </summary>

### 브론즈 23881번 알고리즘 수업 - 선택 정렬 1
- **문제설명** : 선택정렬 수도코드를 제공하고 교환횟수를 체크하여 해당 교환횟수 번째에 교환되는 두개의 수를 출력하는 문제였다. 
- **느낀점** : 선택정렬에 대한 개념이 헷갈려 gif를 다시 보고 코드로 구현했다. 배열의 0번부터 확인하는 버전과 배열의 마지막번째부터 확인하는 버전 둘 다 구현해보았는데 반복문과 크기를 체크하는 것을 꼼꼼히 확인해야해서 어려웠다. 

- *selection sort* <br>
<img src = "https://github.com/whattheyeb/coding_in_RTU/blob/main/img/selection-600.gif" width = 300>
</details>

<details>
<summary> 9/4 <2일차> </summary>

### 브론즈 23882번 알고리즘 수업 - 선택 정렬 2
- **문제설명** : 이번 문제는 23881번 문제에서 약간 변형된 버전으로, 특정 교환 횟수 번째 이후의 정렬을 출력하는 문제였다. 
- **느낀점** : 이제 선택정렬을 구현하는 코드는 비교적 빠르게 작성할 수 있게 되었다. 하지만 for문 안에서 바로 답을 출력하려고 해서 첫번째 시도에서는 실패했었다. 선택정렬을 하는 for문 안에서는 결과를 바로 출력하기보다 flag 사용하거나 배열을 정렬하는 방식을 사용해야겠다.

### 브론즈 10871번 X보다 작은 수
- **문제설명** : 배열과 특정 수를 입력받고 배열 안의 숫자들 중 특정 수보다 작은 수들을 출력한다.
- **느낀점** : 이제 vector를 활용하여 배열을 입력받는 것을 습관들여야겠다.
- **개념정리** : vector 는 c++ 표준라이브러리 (#include <vector>) 에서 제공하는 동적 배열이다. push_back(value) : 맨 뒤에 값 추가, size() : 현재 원소 개수, empty() : 비었는지 확인, clear() : 모든 원소 제거, 초기 정의 : vector<int> v1(10);

### 브론즈 10952번 A + B - 5
- **문제설명** : 정수 a, b를 입력받고 a+b를 출력하는 코드를 작성하는 것, 단, a과 b 둘다 0일때는 아무것도 출력하지않고 종료한다.
- **느낀점** : while 문을 사용하면 a와 b 둘다 0일때에도 둘이 더한 값인 0을 출력하게된다. 그래서 do-while문을 사용했다.

</details>

<details>
<summary> 9/5 <3일차> </summary>

### (브론즈 3) 10818번 최소, 최대 
- **문제설명** : n개의 정수가 주어지고, 이 정수들의 값을 비교하여 최솟값과 최댓값을 구하는 프로그램을 작성
- **느낀점** : ez

### (브론즈 4) 25304번 영수증 
- **문제설명** : 총 금액과 물건의 종류에 대한 입력이 주어지며, 물건의 가격과 개수를 이용하여 실제 담은 금액과 영수증의 총 금액이 일치하는지 확인하는 프로그램을 작성
- **느낀점** : ez

### (브론즈 4) 15552번 빠른 A+B 
- **문제설명** : 정수 a, b를 굉장히 많이 입력받고, a+b를 출력하는 프로그램
- **느낀점** : 새로운 개념을 배웠다!!
- **개념설명** : cin.tie(NULL); 과 sync_with_stdio(false); 를 코드 앞에 작성한 후, endl 대신 \n 을 사용하면 된다. 다음 링크에 설명이 잘 되어있으니 참고해라 https://www.acmicpc.net/blog/view/128 

</details>

<details>
<summary> 9/6 <4일차> </summary>

### (브론즈 5) 10951번 A + B - 4
- **문제설명** : 두 정수 A + B를 입력받은 다음, A + B 를 출력한다.
- **느낀점** : 
- **개념정리** : EOF(End of File) 설정을 해줘야한다. 키보드 입력으로는 윈도우에서 Ctrl+Z 를 눌러 EOF를 발생시킨다. 그럼 반복문에서 조건을 어떻게 설정해야할까? 바로 그냥 while(cin >> a >> b) 이런식으로 조건식에 cin을 넣으면 된다. 

### (브론즈 3) 2562번 최댓값
- **문제설명** : 9개의 다른 자연수가 입력되며, 최댓값과 그 최댓값이 몇번째 수인지를 구하는 프로그램이다.
- **느낀점** : vector를 쓰니까 확실히 코드도 간결해지고 이해하기 쉬워졌다. 번외로 인덱스는 항상 현실 숫자 - 1 라는 것을 기억하자..

### (브론즈 3) 10810번 공넣기
- **문제설명** : 바구니 개수, 공을 넣는 회차 수가 주어진다. 그리고 각 회차마다 공을 넣을 바구니 번호의 범위 (두 개의 수)와 넣을 공의 번호가 주어진다. 공을 넣는 회차가 전부 끝난후, 바구니에 들어있는 공의 번호가 어떻게 되어있는지 출력한다. (단, 각 바구니에는 하나의 공만 들어있을 수 있다. 공이 이미 들어있는 경우 들어있는 공을 빼고 새로운 공을 넣는다)
- **느낀점** : 문제설명이 너무 길어서 읽는 데 힘들었지만 막상 푸는건 쉬웠다. for문 안에 또 다른 for문을 사용할때 조건식의 변수(i, j, k)를 다르게하고 통일시키자

</details>

<details>
<summary> 9/7 <5일차> </summary>

### (브론즈 2) 10813번 공바꾸기
- **문제설명** : 10810번과 기본적인 문제 토대는 같고, 바구니에 들어있는 공을 여러 회차동안 바꾼 후, 최종적으로 바구니에 있는 번호는 무엇인지 출력하는 프로그램을 작성한다
- **느낀점** : 10810번과 매우 비슷하고 swap함수를 사용하여 쉽게 해결했다.

### (브론즈 3) 5597번 과제 안 내신 분..?
- **문제설명** : 30명의 학생들 중 2명의 학생이 과제를 제출하지 않았다. 28개의 학생 번호가 입력으로 들어오면 그 중 제출하지않은 두 학생의 번호를 알아내어 출력한다.
- **느낀점** : for문 안에 변수를 선언하면 그 바깥에서는 초기화된다는 것을 몰랐다. 디버깅 출력 코드를 활용하여 알아내서 다행이다...

### (브론즈 2) 10811번 바구니 뒤집기
- **문제설명** : 10810, 10813번과 기본적인 문제 토대가 같다. 번호가 적힌 바구니를 여러 회차동안 역순으로 만든후, 최종적인 바구니 배열을 출력하는 프로그램을 작성한다.
- **느낀점** : 역순으로 만드는 코드에서 시간을 많이 썼다. 
- **개념정리** : 3번부터 5번 배열 원소를 뒤집어야한다. 그러면 바꾸는 작업이 2번 일어나게된다. (3번과 5번, 4번과 4번) -> swap을 활용한다면, 3부터 시작해서 (3 + 5) / 2 = 4까지, 2번만 반복한 후 끝나야하므로 num1부터 시작하여 num1 + num2 / 2 에서 멈춰야한다. 

### (브론즈 1) 1546번 평균
- **문제설명** : 기말고사 값들이 주어진다. 이 값 중 최댓값을 고르고 모든 점수를 각 과목의 점수 / 최댓값 * 100 을 진행한후 평균을 출력한다.
- **느낀점** : 처음에는 최댓값인 과목의 점수도 위와같이 진행하는지 모르고 있다가 질문게시판을 보고 깨닫게 되었다. 
- **개념정리** : c++ 에서는 int 끼리 나눗셈을 하면 소수점 이하의 숫자는 버려지기 때문에 casting을 해줘야한다. 이 문제를 풀 때에는 static_cast<type>(변수명) 이렇게 해줬다. (double 또는 float 로 선언해도 동일하다. ) 다음 티스토리를 보고 참고했다. https://code-studies.tistory.com/20 

</details>

<details>
<summary> 9/9 <6일차> </summary>

### (실버 5) 2941번 크로아티아 알파벳
- **문제설명** : 문제가 길어서 이미지로 첨부 <img src = "https://github.com/whattheyeb/coding_in_RTU/blob/main/img/bj2941.png" width = 400>
- **느낀점** : 문제는 풀긴했지만 if문남발에다가 복잡하게 작성한 것같아서 챗지피티에게 피드백을 받을 예정이다. 개인적으로 다음 인덱스로 바로 넘어가기위해 for문의 인덱스에 해당하는 i 를 사용한 방법은 마음에 든다. (핵심 아이디어는 “매칭되면 카운트 증가 후 인덱스 건너뛰기”)

### (브론즈 5) 27866번 문자와 문자열
- **문제설명** : 문자열과 숫자를 입력받고, 입력받은 숫자번째에 해당하는 문자를 출력한다. 
- **느낀점** : 기초문제여서 쉽게 풀었다.

### (브론즈 5) 9086번 문자열
- **문제설명** : 여러개의 문자열을 입력받고, 각 문자열의 첫번째 문자와 마지막 문자를 연속해서 출력한다. 
- **느낀점** : size() 함수를 사용하여 쉽게 풀 수 있다.

### (브론즈 5) 11654번 아스키 코드
- **문제설명** : 알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하는 프로그램을 작성하시오.
- **느낀점** : 몰라서 찾아봤다...
- **개념설명** : c++ 에서 문자를 아스키코드로 변환해서 하려면 다음과 같이 코드를 작성하면 된다고 한다. int ascii_value = static_cast<int>(input);

### (브론즈 4) 11720번 숫자의 합
- **문제설명** : 숫자개수와 띄어쓰기없이 쓰여진 숫자배열이 입력된다. 입력으로 주어진 숫자 N개의 합을 출력한다. 
- **느낀점** : 문자열과 관련된 문제라고 생각 안하고 있다가 공백없이 숫자 N개가 주어진다는 글을 보고 문자열로 숫자배열을 입력받고, 각 인덱스로 접근후 아스키코드값을 빼서  더해야겠다는 생각을 했다. 

### (브론즈 2) 10809번 알파벳 찾기
- **문제설명** : 문자열에서 알파벳이 처음 등장하는 위치를 찾아서 저장후 모든 알파벳에 대해 출력한다. 
- **느낀점** : 알파벳 배열을 잘못써서 틀렸다는 게 너무 웃김 (tuvwxyz...) 이런건 직접 찾아서 그냥 복사 붙여넣기하도록 하자. 

</details>

<details>
<summary> 9/10 <7일차> </summary>

### (브론즈 2) 2675번 문자열 반복
- **문제설명** : 테스트케이스 개수 N과 각 문자열 S와 반복횟수 R을 입력받는다. 문자열의 각 문자를 R번씩 반복하여 출력한다. 예시 : (입력) 3 ABC (출력) AAABBBCCC
- **느낀점** : ez

### (브론즈 2) 2908번 상수
- **문제설명** : 각 두개의 3자리 숫자를 입력받는다. 이 숫자를 뒤집은후 크기를 비교해 더 큰 숫자를 출력한다
- **느낀점** : vector의 push_back() 함수를 활용하고 싶어서 int 변수는 하나도 쓰지않았다. 챗지피티의 피드백을 읽고나니 불필요하게 저장공간을 썼음을 알 수 있었다.  

### (브론즈 2) 5622번 다이얼
- **문제설명** : 사진 참고 <br> <img src = "https://github.com/whattheyeb/coding_in_RTU/blob/main/img/bj5622.png" width = 450>
- **느낀점** : if문 폭탄으로 문제를 풀어서 조금 찝찝하다. 챗지피티의 코드를 봤는데 너무 충격적으로 잘짜서 충격임. 알파벳에 시간을 매핑해서 미리 정의한다는 개념을 사용한 것이 대박인거같다. 19줄을 3줄로 줄임

</details>

<details>
<summary> 9/11 <8일차> </summary>

### (브론즈 3) 11718번 그대로 출력하기
- **문제설명** : 입력 받은 문자열을 출력하는 프로그램을 작성하라 (문자열은 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져있다.)
- **느낀점** : 10951번과 비슷한 문제이다. 다만 공백이 포함되어있기때문에 cin이 아닌 getline을 사용해야한다는게 달랐다.
- **개념정리** : #include <string> 라이브러리의 getline(cin, 변수명) 함수를 사용하여 공백이 포함된 문자열 한줄을 입력받을 수 있다. 

### (브론즈 3) 2738번 행렬 덧셈
- **문제설명** : N*M 크기의 두 행렬이 주어졌을때, 두 행렬을 더하는 프로그램을 작성하라
- **느낀점** : 2차원배열을 오랜만에 써서 헷갈렸지만 문제자체가 어렵지않아 간단하게 이중 for문을 사용하여 풀 수 있었다.

</details>

<details>
<summary> 9/12 <9일차> </summary>

### (브론즈 5) 2744번 대소문자 바꾸기
- **문제설명** : 영어 소문자와 대문자로 이루어진 단어를 입력받은 뒤, 대문자는 소문자로, 소문자는 대문자로 바꾸어 출력하는 프로그램을 작성하시오.
- **느낀점** : 대소문자의 아스키코드 차이만큼 더해주고 빼는 로직을 사용하여서 쉬웠다.

### (브론즈 5) 15964번 이상한 기호
- **문제설명** : 입력받은 두 숫자에 대해 A＠B = (A+B)×(A-B) 를 계산한다
- **느낀점** : 그냥 long int 만 쓰면 해결되지않아서(100점 만점 중에 30점만 준다) 구글링을 통해 해결했다. 
- **개념정리** : 두 int 의 값이 커서 int 변수에 담을 수 없다면 long long int를 사용해야한다. long long int output = 1LL * (a + b) * (a - b);

### (브론즈 4) 31403번 A + B - C
- **문제설명** : A, B, C 를 각각 수와 문자열로 생각했을때, A + B - C를 출력하라
- **느낀점** : 테스트케이스에 한자리수만 있어서 단순히 char로 입력받고 '0'만큼 빼서 더하고 빼면 되겠다고 생각했는데 입력 부분에 a, b, c는 1에서 1000사이의 숫자라고 쓰여있는 것을 확인하게 되었다. 

### (브론즈 2) 8958번 OX 퀴즈
- **문제설명** : "OOXXOXXOOO"와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다.
"OOXXOXXOOO"의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다.
OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.
- **느낀점** : 이전 문제의 결과(O,X)에 대해 저장하는 배열 prev를 만들었다. 그런데 X 인 경우에 prev를 0으로 저장하지 않아서 이전 문제의 결과가 X인데도 불구하고 1로 저장되는 경우가 있었다. if 조건 설정과 예외처리를 꼼꼼히 봐야겠다. 로직은 백준 1316번과 비슷해서 쉽게 생각해낼 수 있었다. 

</details>

<details>
<summary> 9/13 <10일차> </summary>

### (브론즈 3) 10250번 ACM 호텔
- **문제설명** :  호텔의 층 수, 각 층의 방 수, 몇 번째 손님인지에 대한 입력이 들어오면, N 번째로 도착한 손님에게 배정될 방 번호를 계산하는 프로그램이다. (링크 참고 : https://www.acmicpc.net/problem/10250 )
- **느낀점** : 문제가 길어서 어려울 거라 생각했는데 2차원배열도 쓰지않고 쉽게 풀 수 있었다. 

### (브론즈 3) 4153번 직각삼각형
- **문제설명** : 주어진 세변의 길이로 삼각형이 직각인지 아닌지 구분하시오.
- **느낀점** : 빗변의 길이의 제곱과 나머지 두변의 길이의 제곱의 합이 같으면 직각삼각형이라는 정의를 그대로 코드에 적용하려고 했다. [1] 최댓값 구하기 [2] 길이의 제곱을 구해서 같은지 확인하는 함수 적용 [3] 출력 이 로직으로 작성했다. [1]파트에서 좀 더 효율적으로 코드를 짤 수 있을지 고민해봐야겠다. 

### (브론즈 3) 30802번 웰컴 키트
- **문제설명** : 참가자들에게 티셔츠와 펜을 줄 건데 얼만큼 준비해야하는지 구하는 문제
- **느낀점** : '펜을 P자루씩 최대 몇 묶음 주문할 수 있고, 그때 한 자루씩 몇 개 주문하는지' 이 말이 이해가 안가서 그냥 입출력 예시 보고 몫과 나머지인가 추측했는데 그게 맞았다. (즉, P자루씩 몇 묶음 주문하고, 남은 나머지는 한 자루씩 주문하라는 뜻이었다...) 문제 이해하는 게 더 힘든 느낌이다
 
</details>

<details>
<summary> 9/14 <11일차> </summary>

### (브론즈 2) 1978번 소수 찾기
- **문제설명** : 주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램
- **느낀점** : 로직은 맞는데 1에 대한 예외처리를 따로 안해줘서 틀린거같아 아쉽다. 

### (브론즈 2) 2231번 분해합
- **문제설명** : 어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 
자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
- **느낀점** : 숫자 N이 주어지고 생성자 M을 구하는 문제여서 이걸 어떻게 구하지? 1부터 N까지 자릿수를 다 더해야하나? 이렇게 생각했다. 챗지피티의 힌트 '(N - N의 자리수 * 9)부터 체크하면 된다.'를 참고하여 문제를 풀었다. 그리고 자리수 구하는 짧은 코드도 이제 알게 되었다...

### (브론즈 2) 2798번 블랙잭 <나중에 다시 풀기>
- **문제설명** : N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.
- **느낀점** : 확률에 나오는 조합(nCr)의 경우의 수를 구하고, 그 수의 합이 M을 넘지 않아야한다고 해서 처음에는 멘붕이 왔다. 조합(중복 X, 순서 X)을 어떻게 코딩해야하는지 몰랐기때문이다. 이 문제는 나중에 다시 풀어봐야겠다. 
- **개념설명** : 조합의 경우 재귀함수로 코드를 작성한다. 다음 블로그에서 코드를 참고했다. https://hongchan.tistory.com/5 

</details>

<details>
<summary> 9/15 <12일차> </summary>

### (브론즈 2) 15829번 Hashing
- **문제설명** : 해시함수를 구현하여 입력받은 문자열을 해시값으로 출력한다.
- **느낀점** : 10일차까지는 그래도 10분안에 풀 수 있는 좀 쉬운 문제들이었는데 이제는 한시간이상은 고민하고 공부해야하는 문제들이 나온다. 수학적 특성(나머지 연산 분배의 법칙)을 적용해야해서 까다로웠던것같다. 
- **개념정리** : 해시함수의 경우 특정수를 거듭제곱하고 더하는 과정에서 long long 의 크기도 벗어나게 된다. 따라서 매 연산마다 mod 를 취해서 오버플로우를 방지해줘야한다. 

### (브론즈 1) 1259번 팰린드롬수
- **문제설명** : 어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. 'radar', 'sees'는 팰린드롬이다. 수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다. 수들을 입력받고 그 수가 팰린드롬수인지 출력하자
- **느낀점** : 이렇게 여러개의 테스트케이스를 입력받는 문제의 경우 내가 flag가 되는 변수들(팰린드롬수인지 저장하는 bool 변수, 각 숫자의 자리수를 저장하는 벡터 등)을 초기화하지 않는 습관이 있다는 것을 인지하게되었다. 주의하자.. 
- **개념정리** : 벡터를 초기화하려면 v.clear() 함수를 호출하면 벡터에 포함된 모든 요소가 제거되고, 비워진다. 

### (브론즈 1) 2775번 부녀회장이 될테야
- **문제설명** : 거주조건이 "a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다"인 아파트의 k층 n호에는 몇 명이 살고 있는지 출력하라
- **느낀점** : 하드코딩해서 제한인 14에 맞춰서 미리 사람들 수를 모두 계산하여 배열에 저장해놓고, 입력받은 테스트케이스에 대해 출력하는 형식으로 코드를 짠 것이 조금 아쉽다. 

</details>

<details>
<summary> 9/16 <13일차> </summary>

### (브론즈 1) 2609번 최대공약수와 최소공배수
- **문제설명** : 두 수를 입력받고, 두 수의 최대공약수와 최소공배수를 구하여 출력한다
- **느낀점** : 두 수가 서로소일때를 고려하지않고 최대공약수 변수를 처음에 0으로 선언해서 런타임에러가 발생했다. (DivisionByZero) 모든 테스트케이스를 고려해봐야겠다. 

### (브론즈 1) 2869번 달팽이는 올라가고싶다 <다시 풀기>
- **문제설명** : 땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다. 달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다. 달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.
- **느낀점** : 처음에 나누는 로직을 생각했는데 예제 출력이랑 다르게 나와서 일일히 다 계산하는 while 문으로 했더니 이 경우는 또 시간이 너무 오래걸렸다. 결국 챗지피티의 힌트를 받아 문제를 해결했다. 다시 풀어야한다..

### (브론즈 1) 28702번 FizzBuzz
- **문제설명** : FizzBuzz 문제는 i = 1, 2, ... 에 대해 특정 규칙에 따라 문자열을 한 줄에 하나씩 출력하는 문제이다. FizzBuzz 문제에서 연속으로 출력된 세개의 문자열이 주어진다. 이 세 문자열 다음에 올 문자열을 구하고 출력해라
- **느낀점** : 입력되는 세개의 문자열 중 하나는 무조건 숫자라는 점을 활용해 Fizz, Buzz, FizzBuzz 가 아닌 문자열이 입력되면 이 문자열의 인덱스와 문자열(숫자)을 vector에 저장한 후 다음에 올 문자열을 구하는 로직으로 구현하였다. 좀 잔머리로 푼거같긴하다...
- **개념정리** : <string> 라이브러리의 stoi함수를 사용하면 string을 int로 쉽게 변환할 수 있다. int 변수 = stoi(string 변수);

</details>

<details>
<summary> 9/17 <14일차> </summary>

### (실버 5) 1436번 영화감독 숌
- **문제설명** : 제일 작은 종말의 수는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 이다. 따라서, 숌은 첫 번째 영화의 제목은 "세상의 종말 666", 두 번째 영화의 제목은 "세상의 종말 1666"와 같이 이름을 지을 것이다. 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 수) 와 같다. 숌이 만든 N번째 영화의 제목에 들어간 수를 출력하는 프로그램을 작성하시오
- **느낀점** : 처음에는 666이 들어가는 수들의 규칙을 찾으려했는데 도저히 못찾아서 챗지피티의 힌트를 얻어서 해결했다. (모든 수를 체크하면서 666이 들어간 수를 찾는 방식)
- **개념정리** : <string>헤더에 int를 string으로 바꾸는 to_string() 함수와 string에 원하는 문자열이 어디 인덱스에 들어있는지 찾아주는 find() 함수

### (브론즈 1) 14626번 ISBN
- **문제설명** : ISBN에는 13자리의 숫자로 표시된다. 그중 마지막 숫자는 체크기호로 정확성여부를 점검하는 숫자이다. 이 체크기호는 일련번호의 앞에서부터 각 자리마다 가중치 1, 3, 1, 3…. 를 곱한 것을 모두 더하고, 그 값을 10으로 나눈 나머지가 0이 되도록 만드는 숫자 m을 사용한다.
손상된 자리의 숫자를 찾아내는 프로그램을 작성하자
- **느낀점** : 문해력이 낮아진건지 문제자체를 이해하고 식을 생각하는데 오래 걸렸다. 그리고 마지막에는 좀 하드하게 3의 나머지들과 매칭하는 식으로 했다가 for문을 돌며 계산하는 방식으로 고쳤다. 코딩테스트 풀려면 문제를 읽고 이해하는것도 꽤나 중요해보인다....

### (실버 5) 7568번 덩치
- **문제설명** : 키도 더 크고, 몸무게도 더 나가는 사람을 덩치가 더 크다라고 말한다고 하자, 사람들의 키와 몸무게를 입력받고 사람의 덩치 등수를 구해서 출력한다. 
- **느낀점** : 간단한 문제를 너무 어렵게생각했다. 각 사람의 경우를 따져서 더 큰 덩치의 사람명수를 저장하고, 사람명수가 없는 사람부터 높은 등수를 주는 방식으로 코드를 작성했었다. 하지만 그럴 필요없이, 덩치를 비교할때부터 자신보다 덩치가 큰 사람이 있다면 등수를 하나씩 낮추면 되는 일이었다. 어차피 각각 사람들에 대해 rank를 체크하는 것이기 때문에 점수가 같은 사람들을 따로 체크할 필요가 없다. 

</details>

<details>
<summary> 9/18 <15일차> </summary>

### (실버 5) 1181번 단어 정렬
- **문제설명** : 알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.
    - 길이가 짧은 것부터
    - 길이가 같으면 사전 순으로
단, 중복된 단어는 하나만 남기고 제거해야 한다.
- **느낀점** : 쉬울줄 알았는데 막상 풀어보니 두가지때문에 어려웠다. 첫번째는 길이가 같을때 각 자리의 아스키코드값을 비교한 후 인덱스를 저장해야한다는 것(compare함수를 쓰지않고 하려니 어려웠다)과 두번째는 중복된 단어는 하나만 남기고 삭제해야한다는 것이었다.  
- **개념정리** : <string> 헤더의 compare 함수는 str1.compare(str2) 로 예시를 들어보면 str1과 str2 가 같을때는 0, str1이 str2보다 클때는 양의 정수, str2이 str1보다 클때는 음의 정수를 return한다.
<algorithm> 헤더의 unique함수는 unique(word.begin(), word.end()) word 배열을 돌면서 겹치는 수를 찾아준다. erase() 함수는 범위를 설정하거나 특정 인덱스 지정하여 벡터를 지울 수 있는 함수이다. 

### (실버 5) 2751번 수 정렬하기 2
- **문제설명** : N개의 수가 주어졌을때, 이를 오름차순으로 정렬하는 프로그램을 작성해라
- **느낀점** : 그냥 편하게 풀고싶어서 algorithm 헤더의 sort 함수를 사용했다. 퀵소트나 머지소트 코드 공부를 좀 시작해야겠다.

### (Easy) Two sum
- **문제설명** : 숫자배열과 target이 주어졌을때, 숫자배열 중 2개 숫자의 조합이 target과 일치한다. 이 2개 숫자의 인덱스를 찾아 vector로 return한다.
- **느낀점** : 내가 푼 방식은 실행시간이 오래걸렸다. 그 이유는 내가 따로 vector 변수에 저장하고 마지막에 return 하려고해서였다. 그럴필요없이 찾는 즉시 해당 배열을 return하면된다.

</details>

<details>
<summary> 9/19 <16일차> </summary>

### (실버 4) 1920번 수 찾기
- **문제설명** : N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.
- **느낀점** : 처음에 시도할때는 linear search (정렬되지않은 상태로 for 문 사용하여 찾기) 로 코드를 작성했다. 당연히, 시간초과가 떴다. 그래서 두번째 시도때는 먼저 배열을 정렬하고, binary search 를 사용하여 작성하고 성공했다. 
- **개념정리** : https://www.geeksforgeeks.org/dsa/binary-search/ 

### (실버 5) 11650번 좌표 정렬하기 <다시 풀기>
- **문제설명** : 2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오
- **느낀점** : 1차원 배열에 대해 정렬하는건 할 수 있는데 2차원 배열에 대해서는 어떻게 풀지 감도 안왔다. 챗지피티의 힌트를 참고하여 먼저 구조체를 만든 후, sort 함수를 사용하여 x 좌표가 같으면 y좌표가 증가하는 함수를 추가하는 방식으로 풀었다. sort함수에 대해 더 알게되었다.
- **개념정리** : sort함수는 세번째 파라미터에 custom comparator를 추가할 수 있다. 
```
bool comp(Point& a, Point& b){
    if(a.x == b.x) return a.y < b.y;
    return a.x < b.x; 
}

int main(){
    sort(points.begin(), points.end(), comp);
}
```

### (easy) Roman to integer
- **문제설명** : 로마숫자로 이루어진 문자열을 입력받아서 아라비아숫자로 변환하는 프로그램을 작성하라 
- **느낀점** : 문제를 주의깊게 안읽고 그냥 일대일대응으로 변환하는 방식으로 풀어서 처음 시도때는 틀렸다. 다시 읽어보니 예외가 있었다.. 그래서 i번째에 검사할때 i + 1번째 문자도 함께 검사하여 만약 한세트인 로마숫자라면 i를 증가시켰다. 


</details>

<details>
<summary> 9/20 <17일차> </summary>

### (실버 5) 25206 너의 평점은
- **문제설명** : 치훈이의 전공평점을 계산해주는 프로그램을 작성해보자. 전공평점은 전공과목별 (학점 × 과목평점)의 합을 학점의 총합으로 나눈 값이다. P/F 과목의 경우 등급이 P또는 F로 표시되는데, 등급이 P인 과목은 계산에서 제외해야 한다.
- **느낀점** : struct를 정의하여 각 과목당 학점과 등급을 저장한 후 전공평점을 구했다. 하지만 아래의 코드처럼 F를 따로 조건을 안빼고 P와 함께 처리해서 틀렸다. F 등급인 경우, 0점으로 계산되지만 학점평균에는 들어가기때문이다.


```
if(s[i].rating != "P"){
            sum += toCredit(s[i].rating) * s[i].credit;
            creditSum += s[i].credit;
        }else if(s[i].rating == "F"){
            sum += 0;
            creditSum += s[i].credit;
}
```

### (브론즈 3) 2566번 최댓값
- **문제설명** :  9×9 격자판에 쓰여진 81개의 자연수 또는 0이 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 행 몇 열에 위치한 수인지 구하는 프로그램을 작성하시오.
- **느낀점** : 81이라는 상수로 정해져있어서 2차원배열을 사용하여 쉽게 풀었다. 

### (브론즈 1) 10798번 세로읽기
- **문제설명** : 한 줄의 단어는 글자들을 빈칸 없이 연속으로 나열해서 최대 15개의 글자들로 이루어진다. 또한 만들어진 다섯 개의 단어들의 글자 개수는 서로 다를 수 있다. 심심해진 영석이는 칠판에 만들어진 다섯 개의 단어를 세로로 읽으려 한다. 세로로 읽을 때, 각 단어의 첫 번째 글자들을 위에서 아래로 세로로 읽는다. 다음에 두 번째 글자들을 세로로 읽는다. 이런 식으로 왼쪽에서 오른쪽으로 한 자리씩 이동 하면서 동일한 자리의 글자들을 세로로 읽어 나간다. 영석이가 읽는 방식으로 글자들을 출력하는 프로그램을 작성하라
- **느낀점** : 인덱스가 출력할 문자열의 길이를 벗어날때를 생각하지않고 처리를 안해줘서 틀렸다. 무지성 제출을 자제해보자 ...

</details>

<details>
<summary> 9/21 <18일차> </summary>

### (실버 5) 1316번 그룹 단어 체커 <다시 풀기>
- **문제설명** : 그룹 단어란 단어에 존재하는 모든 문자에 대해서, 각 문자가 연속해서 나타나는 경우만을 말한다. 예를 들면, ccazzzzbb는 c, a, z, b가 모두 연속해서 나타나고, kin도 k, i, n이 연속해서 나타나기 때문에 그룹 단어이지만, aabbbccb는 b가 떨어져서 나타나기 때문에 그룹 단어가 아니다. 단어 N개를 입력으로 받아 그룹 단어의 개수를 출력하는 프로그램을 작성하시오.
- **느낀점** : 약 일주일전에 이 문제를 마주했을때는 어떻게 풀지도 몰랐는데 그래도 이번에는 약간의 힌트(?)와 함께 푸는 나의 모습을 보며 좀 뿌듯했다. 하지만 다음에 다시 풀어봐야한다...

### (실버 5) 2563번 색종이
- **문제설명** : 가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.
- **느낀점** : 나는 문제를 너무 어렵게(인간처럼) 풀려고 하는것같다. 처음에 문제를 읽었을때 "색종이끼리 겹치는 부분을 어떻게 구하지?" 라는 생각에 사로잡혀서 코드 작성을 시작조차 하지못했다. 하지만 챗지피티의 힌트..(겹치는 부분을 계산할 필요없이 도화지를 100*100 배열로 두고 색종이의 길이에 해당하는 배열을 한칸씩 색칠한다고 생각해라)를 보고 놀랐다...

</details>

<details>
<summary> 9/22 <19일차> </summary>

### (브론즈 1) 2869번 달팽이는 올라가고싶다 - 13일차 복습
- **느낀점** : 기억을 되살리는동안은 버벅였지만 중요한 포인트들(나머지가 있는경우 올림하기, 마지막 날에 올라가는 길이는 미리 빼주기)을 기억해서 풀 수 있었다. 

### (실버 5) 11650번 좌표 정렬하기 - 16일차 복습
- **느낀점** : 벡터에 입력할때 벡터 크기를 정의해주지않으면 오류가 걸리는것같다. 다시 풀때 조금 헷갈려서 깃허브 리드미를 참고하여 풀었다.

### (실버 5) 1193번 분수찾기 (다시 풀기)
- **문제설명** : 이와 같이 나열된 분수들을 1/1 → 1/2 → 2/1 → 3/1 → 2/2 → … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자. X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.
- **느낀점** : 사실 이 문제도 규칙을 못찾아서 챗지피티의 힌트를 받아 풀었다. 사람들이 올린 질문들 보니까 힌트보지말고 스스로 찾으라고 하던데 쩝.. 그래도 충분히 고민했다고 생각한다. (힌트는 다음과 같았다 1. 몇번째 그룹인지 찾기 2. 그룹안에서 몇번째인지 계산하기 3. 홀수인지 짝수인지에 따라 증감방향이 달라짐)

</details>

<details>
<summary> 9/23 <20일차> </summary>

### (실버 4) 2164번 카드 2
- **문제설명** : N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.
이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.
- **느낀점** : 나름 수학적 규칙을 찾았다고 생각했는데 틀린 규칙이었다. 다음에는 queue를 활용해서 푸는 방식을 생각해봐야겠다.

### (브론즈 3) 5086번 배수와 약수
- **문제설명** : 두 수가 주어졌을 때, 다음 3가지 중 어떤 관계인지 구하는 프로그램을 작성하시오.
첫 번째 숫자가 두 번째 숫자의 약수이다. -> "factor" 출력
첫 번째 숫자가 두 번째 숫자의 배수이다. -> "multiple" 출력
첫 번째 숫자가 두 번째 숫자의 약수와 배수 모두 아니다. -> "neither" 출력
- **느낀점** : 간단하게 풀 수 있었던 문제다.

### (브론즈 3) 2501번 약수 구하기
- **문제설명** : 두 개의 자연수 N과 K가 주어졌을 때, N의 약수들 중 K번째로 작은 수를 출력하는 프로그램을 작성하시오.
- **느낀점** : 자연수 N의 약수를 구하면 자연수 N 또한 포함된다는 사실을 까먹었다. 그래서 처음 시도때 틀렸다. 예를 들어 6의 약수 중 4번째로 작은 수는 6이기 때문이다.

</details>

<details>
<summary> 9/24 <21일차> </summary>

### (브론즈 1) 9506번 약수들의 합
- **문제설명** : 어떤 숫자 n이 자신을 제외한 모든 약수들의 합과 같으면, 그 수를 완전수라고 한다. 예를 들어 6은 6 = 1 + 2 + 3 으로 완전수이다.
n이 완전수인지 아닌지 판단해주는 프로그램을 작성하라
- **느낀점** : 약수를 판정하는 로직은 알고있었기에 총합 변수를 지정해두고 약수들을 모두 더한 값을 저장한 후, 완전수인지 아닌지 판단하는 식으로 쉽게 풀 수 있었다.

### (브론즈 2) 2581번 소수
- **문제설명** : 자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.
- **느낀점** : 문제 접근은 맞았는데 M과 N 사이에 소수가 없는 경우를 처리해야한다는 글을 안읽고 풀어서 그 부분에서 틀렸다. 소수의 개수를 카운트하는 cnt 변수를 추가하여 cnt 변수가 0이라면 -1을 출력하도록 수정했다.

</details>

<details>
<summary> 9/25 <22일차> </summary>

### (브론즈 2) 2745번 진법 변환
- **문제설명** : B진법 수 N이 주어진다. 이 수를 10진법으로 바꿔 출력하는 프로그램을 작성하시오.
- **느낀점** : 16진법을 2진수로 변환하는 문제는 논리설계 시간에 많이 풀어봤는데 36진법을 10진법으로 변환하는 문제는 처음이여서 어떻게 풀지 몰랐다. 찾아보니 각 자리수에 N진법의 N을 제곱한 후 다 더해주면 10진법 수로 변환된다고 나왔다. 이 계산법을 똑같이 로직에 적용하여 풀었다. 

### (브론즈 5) 27323번 직사각형
- **문제설명** : 정수 A, B 가 주어진다. 세로 길이가 A cm, 가로 길이가 B cm 인 아래와 같은 직사각형의 넓이를 cm2 단위로 구하시오.
- **느낀점** : 손풀기 문제로 1분만에 풀었다

### (브론즈 3) 1085번 직사각형에서 탈출
- **문제설명** : 한수는 지금 (x, y)에 있다. 직사각형은 각 변이 좌표축에 평행하고, 왼쪽 아래 꼭짓점은 (0, 0), 오른쪽 위 꼭짓점은 (w, h)에 있다. 직사각형의 경계선까지 가는 거리의 최솟값을 구하는 프로그램을 작성하시오.
- **느낀점** : 처음에는 한수의 점에서 각 변까지의 거리들을 다 비교한 후, 최솟값을 구하는 로직으로 생각했는데 천천히 다시 생각해보니 그럴 필요가 없었다! 각 변까지의 거리를 배열에 저장한 후, 최솟값을 구하는 식으로 코드를 작성하면 더 쉬웠다.

### (브론즈 3) 3009번 네 번째 점
- **문제설명** : 세 점이 주어졌을 때, 축에 평행한 직사각형을 만들기 위해서 필요한 네 번째 점을 찾는 프로그램을 작성하시오.
- **느낀점** : 약간 노가다 if문으로 문제를 풀어서 찝찝하다. 

</details>

<details>
<summary> 9/26 <23일차> </summary>

### (브론즈 3) 15894번 수학은 체육과목입니다.
- **문제설명** : "한 변의 길이가 1인 정사각형을 아래 그림과 같이 겹치지 않게 빈틈없이 계속 붙여 나간다. 가장 아랫부분의 정사각형이 n개가 되었을 때, 실선으로 이루어진 도형의 둘레의 길이를 구하시오." 가장 아랫부분의 정사각형 개수가 주어지면 그에 해당하는 답을 출력하는 프로그램을 만들어 형석이를 도와주자!
- **느낀점** : 복잡한 수학 규칙이 있을줄 알았는데 식을 정리하고 나니 answer = 4n 이라는 간단한 식이 나와서 당황했다.

### (브론즈 4) 10101번 삼각형 외우기
- **문제설명** : 창영이는 삼각형의 종류를 잘 구분하지 못한다. 따라서 프로그램을 이용해 이를 외우려고 한다.
삼각형의 세 각을 입력받은 다음,
세 각의 크기가 모두 60이면, Equilateral
세 각의 합이 180이고, 두 각이 같은 경우에는 Isosceles
세 각의 합이 180이고, 같은 각이 없는 경우에는 Scalene
세 각의 합이 180이 아닌 경우에는 Error 를 출력하는 프로그램을 작성하시오.
- **느낀점** : bool 플래그를 사용하여 세각의 크기가 모두 60인 경우를 처리하려고 했는데 잘못 코드를 작성해서 그냥 if문으로 처리했다.

### (브론즈 3) 5073번 삼각형과 세 변
- **문제설명** : 삼각형의 세 변의 길이가 주어질 때 변의 길이에 따라 다음과 같이 정의한다.
Equilateral :  세 변의 길이가 모두 같은 경우
Isosceles : 두 변의 길이만 같은 경우
Scalene : 세 변의 길이가 모두 다른 경우
단 주어진 세 변의 길이가 삼각형의 조건을 만족하지 못하는 경우에는 "Invalid" 를 출력한다. 예를 들어 6, 3, 2가 이 경우에 해당한다. 가장 긴 변의 길이보다 나머지 두 변의 길이의 합이 길지 않으면 삼각형의 조건을 만족하지 못한다. 세 변의 길이가 주어질 때 위 정의에 따른 결과를 출력하시오.
- **느낀점** : 앞서 푼 10101번 문제와 매우 비슷해서 비슷한 로직으로 풀었다. 다른 점은 가장 긴 변의 길이의 인덱스를 따로 빼고 나머지 인덱스들을 벡터에 넣어 저장했다는 점이다. 가장 긴변의 길이 외에 나머지 길이의 인덱스들을 저장한 이유는 두 변의 길이가 같은 경우를 더 짧은 조건문으로 바꾸고싶어서이다. 
- **개념정리** : vector의 첫 원소와 마지막 원소는 각각 v.front(), v.back() 함수를 사용한다.  


</details>

<details>
<summary> 9/27 <24일차> </summary>

### (브론즈 3) 9063번 대지
- **문제설명** : 임씨의 이름이 새겨진 옥구슬의 위치 N 개가 주어질 때에, 임씨에게 돌아갈 대지의 넓이를 계산하는 프로그램을 작성하시오. 
- **느낀점** : 문제가 거의 소설마냥 길어서 어려울까 겁먹었지만 핵심적인 풀이는 간단했다. 좌표 여러개를 입력받고 x좌표와 y좌표의 최댓값, 최솟값를 구한 후, 최댓값과 최솟값의 차이를 곱하는 로직으로 코드를 작성했다.

### (브론즈 3) 14215번 세 막대
- **문제설명** : a, b, c가 주어졌을 때, 만들 수 있는 가장 큰 둘레를 구하는 프로그램을 작성하시오. 
- **느낀점** : 나는 너무 어렵게 이 문제를 풀려고 했었다.. 인덱스에 초점을 맞추고 어느 막대 길이가 같은지를 따졌는데 그럴 필요없이 막대의 길이들을 입력받은 후 크기대로 정렬 후, 계산하면 됐다.

</details>

<details>
<summary> 9/28 <25일차> </summary>

### (브론즈 1) 11005번 진법 변환 2
- **문제설명** : 10진법 수 N이 주어진다. 이 수를 B진법으로 바꿔 출력하는 프로그램을 작성하시오. 10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.
A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35
- **느낀점** : 10진수를 N진수로 바꾸는 방법이 헷갈려서 아래의 티스토리를 참고하면서 풀었다. 10진수가 0이 될때까지 N으로 나누면서 나눌때마다의 나머지를 벡터에 저장하는 방식으로 코드를 작성했다. 또한 나머지가 9를 넘어가는 숫자라면 알파벳으로 변환해주어야하기 때문에 string에 저장한 알파벳 배열과 매칭시켜 변환하는 방식으로 코드를 작성했다.
- **개념정리** : 진법변환의 원리 https://midoriprogramming.tistory.com/16 

</details>

<details>
<summary> 9/29 <26일차> </summary>

### (브론즈 3) 2720번 세탁소 사장 동혁
- **문제설명** : 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 거스름돈 C를 나타내는 정수 하나로 이루어져 있다. C의 단위는 센트이다. 각 테스트케이스에 대해 필요한 쿼터의 개수, 다임의 개수, 니켈의 개수, 페니의 개수를 공백으로 구분하여 출력한다.
- **느낀점** : 그리디 알고리즘을 활용하여 가장 큰 동전부터 나누는 방식으로 코드를 작성했다. 하루전에 강의로 들었던 내용이 나와서 쉽게 풀 수 있었다.

### (브론즈 3) 2903번 중앙 이동 알고리즘
- **문제설명** : 정사각형의 각 변의 중앙에 점을 하나 추가한다. 정사각형의 중심에 점을 하나 추가한다. 과정을 N번 거친 후 점 몇 개를 저장해야 하는지 구하는 프로그램을 작성하시오.
- **느낀점** : 정사각형 위에 생겨나는 점의 개수 규칙을 살펴보면 (이전 정사각형의 한변 위에 있는 점의 개수 * 2 - 1) 의 제곱임을 알 수 있다. 따라서 한 변 위에 있는 점의 개수를 먼저 배열로 만든 후, 입력받은 N에 대해 따로 제곱을 계산하여 제곱하는 방식으로 코드를 작성했다. 

### (브론즈 2) 2292번 벌집 <다시풀기>
- **문제설명** : 입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.
- **느낀점** : 생각보다 규칙은 빠르게 찾았지만 방의 개수를 세는 부분에서 while 문의 조건문을 잘못 설정해서 여러번 틀렸다. 나중에 다시 풀어보자 너무 아쉽다.

</details>

<details>
<summary> 9/30 <27일차> </summary>

### (브론즈 2) 2750번 수 정렬하기
- **문제설명** : N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
- **느낀점** : 최대 1000개의 수를 정렬해야하기 때문에 시간복잡도가 O(nlogn)인 merge sorting algorithm 을 적용하여 문제를 풀었다.
- **개념정리** : merge sort 코드는 다음 사이트를 보고 작성했다. https://www.geeksforgeeks.org/dsa/merge-sort/ 

### (실버 4) 11399번 ATM
- **문제설명** : 첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000), 첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.
- **느낀점** : 알고리즘 라이브러리의 sort 함수를 사용하여 먼저 인출하는 시간이 적은 순서대로 정렬한후 각 사람당 누적 시간을 따로 벡터에 저장했다. 그리고 누적 시간을 모두 더한 값을 출력하는 방식으로 코드를 작성했다. 정렬만 하면 되는 문제라 쉽게 풀었다.

### (실버 5) 1427번 소트인사이드
- **문제설명** : 배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자. 첫째 줄에 정렬하려고 하는 수 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.
- **느낀점** : 4321을 입력받으면 1234로 바꿔서 출력해야하기 때문에 처음에 입력받을때부터 string으로 입력받았다. 그리고 각 자리마다 '0' 아스키값을 빼 int 벡터에 저장했다. 그리고 정렬한 후 출력하는 방식으로 코드를 작성했다. 생각해보니 char 그대로 sorting하면 굳이 int벡터에 저장할 필요가 없을거같기도 하다. 다시 한번 풀어봐야겠다. -> 그냥 char 그대로 sorting하니까 아스키코드값으로 저장이 되어서 마지막에 출력할때 0에 해당하는 아스키코드값인 48을 빼는 방식으로 코드를 작성할 수도 있다!!!

</details>

<details>
<summary> 10/1 <28일차> </summary>

### (브론즈 5) 24262번 알고리즘 수업 - 알고리즘의 수행 시간 1
- **문제설명** : 입력의 크기 n이 주어지면 MenOfPassion 알고리즘 수행 시간을 예제 출력과 같은 방식으로 출력해보자. 첫째 줄에 코드1 의 수행 횟수를 출력한다. 둘째 줄에 코드1의 수행 횟수를 다항식으로 나타내었을 때, 최고차항의 차수를 출력한다. 단, 다항식으로 나타낼 수 없거나 최고차항의 차수가 3보다 크면 4를 출력한다.
- **느낀점** : 처음에는 수행횟수를 따로 세서 출력해야하나? 그리고 다항식으로 나타낸다는건 어떤거지? 하며 혼란스러웠는데 질문게시판의 한 글을 보고 깨달았다. 주어진 알고리즘은 n이 어떤 숫자이든간에 한번 실행되는 O(1)의 시간복잡도를 가진 알고리즘이므로 항상 1과 0을 출력한다.

### (브론즈 4) 24263번 알고리즘 수업 - 알고리즘의 수행 시간 2
- **문제설명** : 24262번 문제와 동일하며 menofpassion 알고리즘 코드 부분만 다르다.
- **느낀점** : 24262번 문제도 그렇고 이 문제들은 코딩을 어떻게 하냐보다 반복문에 따라 시간복잡도가 어떻게 달라지는지 아는지 물어보는 것같다.

### (브론즈 3) 24264번 알고리즘 수업 - 알고리즘의 수행 시간 3
- **문제설명** : 24262번 문제와 동일하며 menofpassion 알고리즘 코드 부분만 다르다.
- **느낀점** : int의 범위를 벗어난 input이여서 long long int로 선언했더니 맞았다. int 범위가 애매하면 long long int로 하자

</details>

<details>
<summary> 10/2 <29일차> </summary>

### (브론즈 3) 24265번 알고리즘 수업 - 알고리즘의 수행 시간 4
- **문제설명** : 24262번 문제와 동일하며 menofpassion 알고리즘 코드 부분만 다르다.
- **느낀점** : menofpassion 알고리즘을 직접 실행하여 수행횟수를 카운트하는 방식으로 코드를 작성했더니 n이 500,000일때는 2~3초를 초과했다. 그래서 규칙을 찾아서 계산하는 방식으로 코드를 수정했다. 

### (브론즈 3) 24266번 알고리즘 수업 - 알고리즘의 수행 시간 5
- **문제설명** : 24262번 문제와 동일하며 menofpassion 알고리즘 코드 부분만 다르다.
- **느낀점** : 이 문제는 시간복잡도를 다항식으로 표현했을때 n^3 인 경우를 표현하고자해서 앞서 푼 문제와 똑같이 n을 세제곱한 것을 출력하는 방식으로 문제를 풀었다.

### (브론즈 3) 24267번 알고리즘 수업 - 알고리즘의 수행 시간 6
- **문제설명** : 24262번 문제와 동일하며 menofpassion 알고리즘 코드 부분만 다르다.
- **느낀점** : 먼저 menofpassion 반복문을 실행하고 규칙을 발견한 후 해당 규칙을 적용시켜서 출력하는 방식으로 코드를 작성했다. 

</details>

<details>
<summary> 10/3 <30일차!!!> </summary>

### (실버 5) 24313번 알고리즘 수업 - 점근적 표기 1
- **문제설명** : 알고리즘의 소요 시간을 나타내는 O-표기법(빅-오)을 다음과 같이 정의하자. 
```
O(g(n)) = {f(n) | 모든 n ≥ n0에 대하여 f(n) ≤ c × g(n)인 양의 상수 c와 n0가 존재한다}
```
함수 f(n) = a1n + a0, 양의 정수 c, n0가 주어질 경우 O(n) 정의를 만족하는지 알아보자.

- **느낀점** : c >= a0 이 조건을 추가하지 않아서 첫 시도에는 틀렸다. 이 조건을 왜 추가해야하는지에 대해 의문이 들었는데 천천히 생각해보니까 f(n) 이 4n - 2이고 c * g(n) 이 2n이라면 f(n) ≤ c × g(n) 이 식에 대해서는 만족하지만 모든 n에 대해서는 만족하지 않는다.

### (브론즈 2) 2587번 대표값2
- **문제설명** : 다섯 개의 자연수가 주어질 때 이들의 평균과 중앙값을 구하는 프로그램을 작성하시오.
- **느낀점** : 벡터로 입력받고 입력받을때마다 sum 변수에 더하고 5로 나눈값을 출력하는 방식으로 풀었다. 입력개수가 5로 정해져있어서 기본문제로 느껴졌다.

### (브론즈 2) 25305번 커트라인
- **문제설명** : 2022 연세대학교 미래캠퍼스 슬기로운 코딩생활에 
$N$명의 학생들이 응시했다.이들 중 점수가 가장 높은 $k$명은 상을 받을 것이다. 이 때, 상을 받는 커트라인이 몇 점인지 구하라.
커트라인이란 상을 받는 사람들 중 점수가 가장 가장 낮은 사람의 점수를 말한다.
- **느낀점** : 선택정렬 코드를 잘못 써놓고 다른데서 뭐가 잘못됐는지를 찾고있었다. 선택정렬에서 swap하는건 각 인덱스마다 최대한번이다...

</details>

<details>
<summary> 10/4 <31일차> </summary>

### (브론즈 1) 10989번 수 정렬하기 3 <다시 풀기>
- **문제설명** : N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
- **느낀점** : 계수정렬(counting sort)을 이용해서 처음 문제를 풀었는데 이렇게 메모리를 절약하면서 빠르게 정렬할 수 있다는것에 놀랐다. counting sort 공부하고 다시 풀어봐야겠다.

### (실버 5) 11651번 좌표 정렬하기 2
- **문제설명** : 2차원 평면 위의 점 N개가 주어진다. 좌표를 y좌표가 증가하는 순으로, y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.
- **느낀점** : 좌표정렬하기 1번이랑 똑같고 조건만 다르게 설정하면 돼서 쉽게 풀 수 있었다.

</details>

<details>
<summary> 10/5 <32일차> </summary>

### (브론즈 2) 19532번 수학은 비대면강의입니다
- **문제설명** : 다음 연립방정식에서 x 와 y의 값을 계산하시오.
```
ax + by = c
dx + ey = f
```
- **느낀점** : 양변에 d, a를 곱해서 x의 계수를 같게 한후 두 식을 빼는 형식으로 풀었다. 처음에는 y의 값을 구한후, (c - by) / a 이 방식으로 x를 구하려고 했는데 a가 0일수도 있기때문에 DivisionBy0 에러가 떴다. 그래서 양변에 d, a를 곱해서 푼것처럼 b, e를 곱해서 풀었더니 해결되었다.

### (실버 3) 1018번 체스판 다시 칠하기 <다시 풀기>
- **문제설명** : 지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.

체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.

보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.
- **느낀점** : 체스판의 각 칸의 색을 체크하는 알고리즘은 생각해냈는데 8*8 크기의 체스판만큼에서 최소 개수를 구하는 알고리즘에서 막혀서 챗지피티의 힌트를 받았다. 다시 풀어보자...

</details>

<details>
<summary> 10/6 <33일차> </summary>

### (실버 2) 18870번 좌표 압축
- **문제설명** : 수직선 위에 N개의 좌표 X1, X2, ..., XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다. Xi를 좌표 압축한 결과 X'i의 값은 Xi > Xj를 만족하는 서로 다른 좌표 Xj의 개수와 같아야 한다. X1, X2, ..., XN에 좌표 압축을 적용한 결과 X'1, X'2, ..., X'N를 출력해보자.
- **느낀점** : 먼저 입력받은 좌표 배열과 똑같은 배열을 만든다. 그리고 복사한 배열을 오름차순으로 sorting하고, 중복된 값은 삭제한다. 입력받은 좌표 배열 원소 하나하나씩 반복문을 돌면서 binarysearch를 이용하여 정렬된 배열 중 어디 인덱스에 위치해있는지 찾는다. 인덱스가 곧 자신보다 작은 좌표의 개수이기 때문이다. 이런 로직으로 작성했는데 처음에는 binarysearch를 사용하지 않아서 시간초과가 나왔다. 

</details>

<details>
<summary> 10/7 <34일차> </summary>

### (실버 5) 10815번 숫자 카드
- **문제 설명** : 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.
- **느낀점** : 처음에 문제 풀때는 sorting하지않고 binary search도 쓰지않은채로 그냥 find()함수만 사용하여 코드를 작성했더니 시간 초과가 나왔다. 질문 게시판을 참고하여 입력받은 배열을 sorting한후, binary search로 찾아서 0, 1을 출력하도록 했더니 시간초과는 뜨지않았지만 97%에서 틀렸다. 찾아보니 binary search에서 배열의 사이즈 - 1을 해야한다고 되어있었다. 만약 a.size() 로 했다면 low = high = a.size()인 경우 mid = a.size()이므로 벡터의 범위를 초과하게 된다. 

</details>

<details>
<summary> 10/8 <35일차> </summary>

### (실버 3) 분수 합
- **문제설명** : 분수 A/B는 분자가 A, 분모가 B인 분수를 의미한다. A와 B는 모두 자연수라고 하자. 두 분수의 합 또한 분수로 표현할 수 있다. 두 분수가 주어졌을 때, 그 합을 기약분수의 형태로 구하는 프로그램을 작성하시오. 기약분수란 더 이상 약분되지 않는 분수를 의미한다.
- **느낀점** : 아래처럼 for문과 if문을 사용하여 기약분수를 만들려고했다. 
'''
for(int i = 2; i <= b1Copy; i++){ 
    if((b1 % i == 0) && (b2 % i == 0)){ 
        num *= i; b1 /= i; b2 /= i; 
    } 
}
'''
여러 예시 입력에도 다 올바른 답이 나와 문제점을 몰랐는데 아주 큰 결점이 있었다. 바로 똑같은 인수에 대해서는 처리하지 못한다는 점이다. 예를 들어 8과 12라는 숫자를 예시로 들면 2로 한번 나뉘고 다시 2로 나뉘어야하는데 나의 코드는 각 숫자에 대해서 한번씩만 나누기 때문에 틀린것이다. 
결국 나의 옛날 최대공약수 및 최소공배수 코드를 보며 복습했다. 

</details>

<details>
<summary> 10/11 <36일차> </summary>

### (실버 5) 13241번 최소공배수
- **문제설명** : 한 줄에 두 정수 A와 B가 공백으로 분리되어 주어진다.
50%의 입력 중 A와 B는 1000(103)보다 작다. 다른 50%의 입력은 1000보다 크고 100000000(108)보다 작다.
- **느낀점** : 문제의 설명에 유클리드 호제법을 활용하라는 글이 있어 해당 알고리즘을 활용했다. 기존에 내가 작성했었던 최대공약수를 구하는 알고리즘보다 훨씬 간단하고 빠른 알고리즘이다. 

### (실버 4) 2485번 가로수
- **문제설명** : 직선으로 되어있는 도로의 한 편에 가로수가 임의의 간격으로 심어져있다. KOI 시에서는 가로수들이 모두 같은 간격이 되도록 가로수를 추가로 심는 사업을 추진하고 있다. KOI 시에서는 예산문제로 가능한 한 가장 적은 수의 나무를 심고 싶다. 편의상 가로수의 위치는 기준점으로 부터 떨어져 있는 거리로 표현되며, 가로수의 위치는 모두 양의 정수이다.

예를 들어, 가로수가 (1, 3, 7, 13)의 위치에 있다면 (5, 9, 11)의 위치에 가로수를 더 심으면 모든 가로수들의 간격이 같게 된다. 또한, 가로수가 (2, 6, 12, 18)에 있다면 (4, 8, 10, 14, 16)에 가로수를 더 심어야 한다.

심어져 있는 가로수의 위치가 주어질 때, 모든 가로수가 같은 간격이 되도록 새로 심어야 하는 가로수의 최소수를 구하는 프로그램을 작성하라. 단, 추가되는 나무는 기존의 나무들 사이에만 심을 수 있다.
- **느낀점** : 가로수의 간격을 저장한 후, 이 모든 간격의 최대공약수를 구해서 풀었다. 처음에 문제를 읽었을때는 모든 가로수가 같은 간격이 되도록 하지만 새로 심어야하는 가로수가 최소가 되어야한다고 해서 막혔었는데 천천히 단계별로 생각하니 풀렸다. 나이스

### (실버 4) 4134번 다음 소수 <다시 풀기>
- **문제설명** : 정수 n(0 ≤ n ≤ 4*10^9)가 주어졌을 때, n보다 크거나 같은 소수 중 가장 작은 소수 찾는 프로그램을 작성하시오.
- **느낀점** : 처음에는 소수인걸 찾는 프로그램을 작성하는 줄 알고 쉬울거라 생각했지만, n보다 크거나 같은 소수 중 가장 작은 소수를 찾는 프로그램이여서 시간이 걸렸다. n의 제곱근만큼만 나눠서 소수를 찾았고, 만약 소수가 아니라면 소수가 될때까지 num에 1씩 더하는 방식으로 찾았다. 그리고 챗지피티의 힌트인 "짝수인지 먼저 판정을 내린 후, +2를 해서 소수를 찾으면 더 빠르다"를 참고했다. 

</details>

<details>
<summary> 10/12 <37일차> </summary>

### <실버 3> 1929번 소수 구하기
- **문제설명** : M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.
- **느낀점** : 어제 배웠던 소수 구하기 스킬들을 종합해서 쉽게 풀 수 있었다! 어제의 복습용 문제였는데 안보고 기억해내서 풀었다는게 뿌듯하다.

</details>

<details>
<summary> 10/13 <38일차> </summary>

### <실버 3> 4948번 베르트랑 공준
- **문제설명** : 베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다.
이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다.
자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오. .
- **느낀점** : 어제와 똑같은 알고리즘으로 (먼저 2로 나눈 후, 3-5-7-9 이런식으로 2씩 늘려가며 나누어 소수를 판정한다) 풀었더니 한번에 맞았다!! 얏호 이제 소수는 완벽마스터한 기분이 든다.

</details>

<details>
<summary> 10/14 <39일차> </summary>

- **문제설명** : 골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.
짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다. 짝수 N이 주어졌을 때, 골드바흐 파티션의 개수를 구해보자. 두 소수의 순서만 다른 것은 같은 파티션이다.
- **느낀점** : 두 소수의 조합을 어떻게 구할지 고민했는데 마땅히 좋은 알고리즘이 생각나지 않아서 그냥 브루트포스로 소수 2부터 하나씩 다 확인해보자라는 마인드로 문제를 풀었다. 처음에 풀었을때는 시간초과가 나서 고민고민하다가 도저히 모르겠어서 질문게시판을 확인했더니 매 입력마다 소수인지 아닌지 확인하는 것은 매우 비효율적이고, 100만까지의 bool 배열을 따로 만들어서 확인하는 것이 낫다는 글을 봤다. 그래서 나도 이 방식을 채택해서 풀었더니 해결할 수 있었다! 

</details>

<details>
<summary> 10/16 <40일차> </summary>

- **문제설명** : 서강대학교 컴퓨터공학과 실습실 R912호에는 현재 N개의 창문이 있고 또 N명의 사람이 있다. 1번째 사람은 1의 배수 번째 창문을 열려 있으면 닫고 닫혀 있으면 연다.  2번째 사람은 2의 배수 번째 창문을 열려 있으면 닫고 닫혀 있으면 연다. 이러한 행동을 N번째 사람까지 진행한 후 열려 있는 창문의 개수를 구하라. 단, 처음에 모든 창문은 닫혀 있다.

예를 들어 현재 3개의 창문이 있고 3명의 사람이 있을 때,

1번째 사람은 1의 배수인 1,2,3번 창문을 연다. (1, 1, 1)
2번째 사람은 2의 배수인 2번 창문을 닫는다. (1, 0, 1)
3번째 사람은 3의 배수인 3번 창문을 닫는다. (1, 0, 0)
결과적으로 마지막에 열려 있는 창문의 개수는 1개 이다.

창문 및 사람 수가 주어지면 마지막에 열려있는 창문의 개수를 출력하라.

- **느낀점** : 첫번째 시도때는 불필요한 (배열)벡터사용으로 인해 메모리초과가 일어났다. 두번째 시도때는 약수의 개수를 일일히 세는 알고리즘으로 인해 시간초과가 일어났다. 약수의 개수의 홀짝을 파악해 창문의 여닫음을 판정한다는 것은 알았다. 하지만 약수의 개수가 홀수일때는 어떤 수의 제곱수일때만이라는 것을 간과하고 있었다. 

</details>

<details>
<summary> 10/16 <41일차> </summary>

### <실버 4> 2839번 설탕 배달
- **문제설명** : 상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다. 상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다. 상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.
- **느낀점** : 처음에는 그냥 5로 나누고 나머지값을 3으로 배정하면 되지않나 생각했지만 문제가 그렇게 쉽지않았다. 예를들어 21의 경우 5*3 + 3*2 이렇게 나뉘어진다. 그래서 for문을 사용하여 5킬로그램 봉지를 하나씩 늘려가며 3으로 나뉘어지는 순간의 봉지개수를 체크했다. 그리고 최소봉지개수 변수를 추가하여 봉지개수가 최소일때를 찾았다. 

### <실버 4> 14425번 문자열 집합
- **문제설명** : 총 N개의 문자열로 이루어진 집합 S가 주어진다. 입력으로 주어지는 M개의 문자열 중에서 집합 S에 포함되어 있는 것이 총 몇 개인지 구하는 프로그램을 작성하시오.
- **느낀점** : 처음에는 당연히 그냥 for 반복문을 사용해서 적은 입력수에는 해결할 수 있었다. 하지만 문제에서 요구하는 것은 binary search를 사용하여 시간초과가 나지않게 빠르고 효율적으로 코드를 작성하라는 것이었다. 나는 이 의도를 질문게시판을 보고 알았다... 여러개의 집합에서 특정 요소를 찾아내는 문제가 나오면 binary search를 활용해야겠다. 

</details>

<details>
<summary> 10/17 <42일차> </summary>

### <실버 4> 28278번 스택 2
- **문제설명** : 정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.
명령은 총 다섯 가지이다.
1 X: 정수 X를 스택에 넣는다. (1 ≤ X ≤ 100,000)
2: 스택에 정수가 있다면 맨 위의 정수를 빼고 출력한다. 없다면 -1을 대신 출력한다.
3: 스택에 들어있는 정수의 개수를 출력한다.
4: 스택이 비어있으면 1, 아니면 0을 출력한다.
5: 스택에 정수가 있다면 맨 위의 정수를 출력한다. 없다면 -1을 대신 출력한다.
- **느낀점** : 처음에는 링크드 스택으로 문제를 해결하려고 했는데 new 와 delete가 반복적으로 사용되면 시간초과가 된다고 하여 그냥 stl을 사용하여 풀었다. 찝찝하게 푼거같아 나중에 스택 공부를 하고 다시 풀어봐야겠다.

</details>

<details>
<summary> 10/18 <43일차> </summary>

### <실버 4> 10773번 제로
- **문제설명** : 나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다. 재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다. 재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다. 재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!
- **느낀점** : stack 문제집에 들어있었던 문제라 stack을 활용할 생각을 했고, 문제에서 의도하는 바가 pop과 top 기능을 사용해라! 인것같아 그 기능을 활용했다. 다만 마지막에 남은 수의 합을 구할때 stack의 사이즈로 설정을 했는데 하나씩 빠지는 느낌이 들어서 왜지? 싶었는데 질문게시판을 보니 stack에서 pop을 실행할때마다 size가 자동으로 줄어들기때문이었다. 그래서 그냥 따로 변수를 추가해서 push를 할때 +1, pop할때 -1을 하는 방식으로 개수를 셌다. 

</details>

<details>
<summary> 10/19 <44일차> </summary>

### <실버 4> 9012번 괄호
- **문제설명** : 괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다. 
여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다. 
- **느낀점** : 왼쪽괄호, 오른쪽괄호 개수를 세서 같으면 yes 아니면 no 로 판정내리는 알고리즘으로 작성했는데 틀렸다. 왜 틀렸냐면 처음 시작이 무조건 왼쪽 괄호여야한다. 따라서 왼쪽괄호와 오른쪽괄호의 균형을 체크하는 변수와 균형이 깨졌는지 아닌지를 체크하는 변수, 총 두가지 변수가 있어야한다. 

</details>

<details>
<summary> 10/20 <45일차> </summary>

- **문제설명** : 준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다. 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.
- **느낀점** : 동전의 가치가 배수여서 간단하게 풀 수 있었다. 이제 어려운 문제도 좀 풀어야하는데 수준이 확어려워지만 손도 못대겠다.

</details>

<details>
<summary> 10/21 <46일차> </summary>

- **문제설명** : 녹색거탑의 높이를 나타내는 정수 N이 주어지면 정상에서 바닥으로 내려오는 경우의 수를 출력한다
- **느낀점** : 손으로 그려서 규칙을 찾았다고 생각했는데 잘못찾아서 2번 틀렸다. 뇌가 덜 풀렸나보다

</details>

<details>
<summary> 10/22 <47일차> </summary>

- **문제설명** : 상근이는 모든 사람의 출입카드 시스템의 로그를 가지고 있다. 이 로그는 어떤 사람이 회사에 들어왔는지, 나갔는지가 기록되어져 있다. 로그가 주어졌을 때, 현재 회사에 있는 모든 사람을 구하는 프로그램을 작성하시오. 첫째 줄에 로그에 기록된 출입 기록의 수 n이 주어진다. (2 ≤ n ≤ 106) 다음 n개의 줄에는 출입 기록이 순서대로 주어지며, 각 사람의 이름이 주어지고 "enter"나 "leave"가 주어진다. "enter"인 경우는 출근, "leave"인 경우는 퇴근이다.
- **느낀점** : c++로는 hash table을 코딩해보지않아서 어려울거라 생각했는데 막상 따라서 해보니까 어렵지 않았다. hash table을 사용하니까 훨씬 쉽게 풀 수 있었다. 몰라도 겁먹지말자

</details>

<details>
<summary> 10/23 <48일차> </summary>

### <실버 4> 1620번 나는야 포켓몬 마스터 이다솜
- **문제설명** : 포켓몬 데이터들을 입력받는다, 그리고 포켓몬이름 주어지면 해당 도감 번호를, 번호가 주어지면 해당 포켓몬이름을 출력하는 프로그램을 작성하라. 
- **느낀점** : 맵 문제인줄 알았지만 포켓몬 번호와 포켓몬 이름만 있다면 벡터로도 해결할 수 있지않을까? 라는 생각을 하고 풀어서 첫번째 시도때 틀렸다. 하지만 이름 입력이 들어왔을때 find 함수로 찾으려고 하면 한세월이 걸린다 (시간초과) 질문게시판을 보다가 번호와 이름을 바꿔서 맵으로 코드를 짠 사람을 보자마자 으악 소리가 나왔다. (map<string, int> 형식) 결국 해결할 수 있엇다. 

</details>

<details>
<summary> 10/24 <49일차> </summary>

### <실버 4> 10816번 숫자카드 2
- **문제설명** : 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.
- **느낀점** : 이제 map은 어느정도 마스터한 기분이 든다. 이번 문제는 거의 10분만에 풀었다. 

</details>

<details>
<summary> 10/25 <50일차> </summary>

### <실버 4> 1764번 듣보잡
- **문제설명** :첫째 줄에 듣도 못한 사람의 수 N, 보도 못한 사람의 수 M이 주어진다. 이어서 둘째 줄부터 N개의 줄에 걸쳐 듣도 못한 사람의 이름과, N+2째 줄부터 보도 못한 사람의 이름이 순서대로 주어진다. 이름은 띄어쓰기 없이 알파벳 소문자로만 이루어지며, 그 길이는 20 이하이다. N, M은 500,000 이하의 자연수이다. 듣도 못한 사람의 명단에는 중복되는 이름이 없으며, 보도 못한 사람의 명단도 마찬가지이다. 듣보잡의 수와 그 명단을 사전순으로 출력한다.
- **느낀점** : 처음에 map 을 사용하여 듣도 못한 사람을 입력받고 두번째에 보도 못한 사람은 string 변수로 입력받고 바로 find 함수를 사용하여 듣도못한사람 map에 있는지 확인했다. 만약 있으면 듣도 보도 못한 사람이기 때문에 바로 벡터 변수에 추가해줬다. 그리고 출력해주는 방식으로 한번에 문제 풀었다 ^0^

</details>

<details>
<summary> 10/27 <51일차> </summary>

### <실버 4> 1269번 대칭 차집합
- **문제설명** : 자연수를 원소로 갖는 공집합이 아닌 두 집합 A와 B가 있다. 이때, 두 집합의 대칭 차집합의 원소의 개수를 출력하는 프로그램을 작성하시오. 두 집합 A와 B가 있을 때, (A-B)와 (B-A)의 합집합을 A와 B의 대칭 차집합이라고 한다. 예를 들어, A = { 1, 2, 4 } 이고, B = { 2, 3, 4, 5, 6 } 라고 할 때,  A-B = { 1 } 이고, B-A = { 3, 5, 6 } 이므로, 대칭 차집합의 원소의 개수는 1 + 3 = 4개이다.
- **느낀점** : 문제를 푸는 알고리즘은 이전 문제들과 비슷했기 때문에 쉽게 생각할 수 있었다. map이랑 vector를 번갈아 사용하다보니 문법이 헷갈렸다. 
unordered_map의 원소를 하나씩 접근하기 위해서는 다음과 같이 코드를 작성해야한다. 
```
for(auto it = m.begin(); it != m.end(); ++it){
    // key에 접근
    cout << "Key 값 : " << it -> first << endl;
    // value에 접근
    cout << "Value 값 : " << it -> second << endl;
}
```

### <실버 4> 10828번 스택
- **문제설명** : push, pop, size, empty, top 스택의 기본 명령어들을 구현하는 프로그램을 작성하시오.
- **느낀점** : vector를 사용해서 한땀한땀 stack을 구현해보는건 처음이라 어려울거라 생각했는데 의외로 실행도 잘되고 시간초과도 발생하지 않았다. 기본적으로 vector의 push_back이나 pop_back 기능이 stack과 유사하다고 여겨져서 해당 기능을 push 와 pop에서 사용했다. size나 empty 또한 vector의 기본 함수에 있어서 그걸 활용했다. 추가적으로 top 변수를 사용해 top 이 0이면 -1을 출력하도록 했다. 

</details>

<details>
<summary> 10/28 <52일차> </summary>

### <실버 3> 11478번 서로 다른 부분 문자열의 개수
- **문제설명** : 문자열 S가 주어졌을 때, S의 서로 다른 부분 문자열의 개수를 구하는 프로그램을 작성하시오. 부분 문자열은 S에서 연속된 일부분을 말하며, 길이가 1보다 크거나 같아야 한다. 예를 들어, ababc의 부분 문자열은 a, b, a, b, c, ab, ba, ab, bc, aba, bab, abc, abab, babc, ababc가 있고, 서로 다른것의 개수는 12개이다.
- **느낀점** : map을 사용하면 중복된 원소를 빨리 찾을 수 있기때문에 map을 사용했고 부분문자열을 만들때는 string 라이브러리의 substr() 함수를 사용했다. 


</details>

<details>
<summary> 10/29 <53일차> </summary>

### <실버 4> 10845번 큐
- **문제설명** : 정수를 저장하는 큐를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오. (push, pop, size, empty, front, back)
- **느낀점** : 스택과 비슷한 방식으로 구현했다. 다만 이번에는 벡터의 함수 중 front, back, erase 를 활용하여 문제를 해결했다. erase는 원하는 벡터의 원소를 삭제하고, 벡터의 사이즈도 자동으로 줄여준다. v.erase(v.begin()) 이런식으로 활용했다. 

</details>

<details>
<summary> 10/30 <54일차> </summary>

### <실버 4> 11866번 요세푸스 문제 0 <다시 풀기>
- **문제설명** : 요세푸스 문제는 다음과 같다.
1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.
N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오
- **느낀점** : 오랜만에 고생하면서 푼 문제였다. linked list를 구현할 줄 알아야하고, k번째 원소를 없애면서 나머지 원소들의 인덱스는 알고있어야하기 때문에 어떻게 구현할지 어려웠다. 질문 게시판의 코드를 참고했기때문에 다시 풀어봐야할 문제이다.. 

</details>

<details>
<summary> 👻 10/31 👻 <55일차> </summary>

### <브론즈 4> 15439번 베라의 패션
- **문제설명** : 베라는 상의 N 벌과 하의 N 벌이 있다. i 번째 상의와 i 번째 하의는 모두 색상 i를 가진다. N 개의 색상은 모두 서로 다르다.
상의와 하의가 서로 다른 색상인 조합은 총 몇 가지일까?
- **느낀점** : 예시출력보고 n * (n - 1) 규칙을 가진걸 찾아서 쉽게 풀 수 있었다. 예를 들어 5벌이 있다면 상의 하나당 다른 색을 가진 4개의 하의로 조합을 맞출 수 있기때문에 5 * 4 = 20 조합이 된다. 

</details>

<details>
<summary> 11/1 <56일차> </summary>

### <실버 5> 1010번 다리 놓기
- **문제설명** : 재원이는 서쪽의 사이트 n개와 동쪽의 사이트 m개를 다리로 연결하려고 한다. (이때 한 사이트에는 최대 한 개의 다리만 연결될 수 있다.) 재원이는 다리를 최대한 많이 지으려고 하기 때문에 서쪽의 사이트 개수만큼 (N개) 다리를 지으려고 한다. 다리끼리는 서로 겹쳐질 수 없다고 할 때 다리를 지을 수 있는 경우의 수를 구하는 프로그램을 작성하라.
- **느낀점** : 처음에는 조합 공식으로 풀려고했는데 겹쳐질 수 없다는 조건을 보고 다이나믹 프로그래밍으로 풀어야한다는 것을 깨달았다. 근데 다이나믹 프로그래밍으로 문제를 푼적이 없어서 강의를 보고 배열에 중복되는 계산 결과값을 기록해두고 사용한다는 것을 알게 되었다. 먼저 다리의 규칙을 표로 만들어보고 그 표를 다이나믹 프로그래밍 코드로 구현하는 것에 초점을 뒀다.  

</details>

<details>
<summary> 11/2 <57일차> </summary>

### <실버 3> 1003번 피보나치 함수
- **문제설명** : 피보나치 수를 구하는 c++ 함수를 호출했을때 0과 1이 각각 몇번 출력되는지 구하는 프로그램을 작성하시오.
```
int fibonacci(int n) {
    if (n == 0) {
        printf("0");
        return 0;
    } else if (n == 1) {
        printf("1");
        return 1;
    } else {
        return fibonacci(n‐1) + fibonacci(n‐2);
    }
}
```
- **느낀점** : 처음에는 단순하게 4라면 3과 1로 나뉘어지고, 5라면 4와 1로 나뉘어진다고 생각해서 틀렸다. 다시 피보나치 함수 코드를 읽어보니 n - 1과 n - 2의 피보나치함수를 호출하니까 0과 1을 호출하는 횟수를 담는 dp 배열을 만들고 미리 저장해야하는구나를 깨달았다. 

</details>

<details>
<summary> 11/3 <58일차> </summary>

### <실버 5> 11723번 집합 
- **문제설명** : 비어있는 공집합 S가 주어졌을 때, 아래 연산을 수행하는 프로그램을 작성하시오.
add x: S에 x를 추가한다. (1 ≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다.
remove x: S에서 x를 제거한다. (1 ≤ x ≤ 20) S에 x가 없는 경우에는 연산을 무시한다.
check x: S에 x가 있으면 1을, 없으면 0을 출력한다. (1 ≤ x ≤ 20)
toggle x: S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1 ≤ x ≤ 20)
all: S를 {1, 2, ..., 20} 으로 바꾼다.
empty: S를 공집합으로 바꾼다.
- **느낀점** : vector의 기본함수들(clear, push_back, erase, find)을 활용하여 쉽게 풀 수 있었다. (find함수는 algorithm 헤더파일에 포함된 함수이다. )


</details>

<details>
<summary> 11/4 <59일차> </summary>

### <실버 3> 1463번 1로 만들기 <다시풀기>
- **문제설명** : 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
> X가 3으로 나누어 떨어지면, 3으로 나눈다.
> X가 2로 나누어 떨어지면, 2로 나눈다.
> 1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
- **느낀점** : 연산이 반복되고, 이전에 쓰인 값들이 재사용된다는 규칙을 찾아서 다이나믹 프로그래밍으로 풀어야하는구나를 깨달았다. 처음에는 식을 찾느라 고생했는데 3이나 2로 나뉘어지는 값 중 최솟값을 사용한다는 것을 찾았다. 하지만 두번째 시도때 질문게시판을 참고했기때문에 다시 풀어야한다...

</details>

<details>
<summary> 11/5 <60일차> 👍👍 </summary>

### <실버 3> 11659번 구간 합 구하기 4
- **문제설명** : 수 N개가 주어졌을 때, i번째 수부터 j번째 수까지 합을 구하는 프로그램을 작성하시오.
- **느낀점** : 일일히 i ~ j번째 수까지의 합을 for문으로 더하면 당연히 시간초과가 나기때문에 미리 모든 구간합을 구해놓은뒤 S(j) - S(i - 1) 식을 통해 바로바로 출력하는 방식으로 문제를 해결했다. 역시 코딩에는 수학이 필수적임을 깨닫는다.

</details>

<details>
<summary> 11/6 <61일차> </summary>

### <실버 3> 2606번 바이러스 <다시풀기>
- **문제설명** : 첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하인 양의 정수이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다 1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.
- **느낀점** : bfs 를 처음 구현해봐서 유튜브영상강의를 보면서 코드를 작성했다. 처음에는 단방향으로 코드를 작성해서 틀렸는데 양방향으로 고쳐서 맞았다. 다시 풀어봐야겠다. 

</details>

<details>
<summary> 11/7 <62일차> </summary>

- 어제 풀었던 바이러스 문제를 다시 풀어봤다. bfs 구현 코드를 다시 써보면서 왜 queue로 구현하는지도 알게되었다. 

### <실버 3> 11726번 2xn 타일링 
- **문제설명** : 2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오. (첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.)
- **느낀점** : 출력에 10007로 나누는게 있어서 뭥미? 하면서 딱히 의미가 없다고 생각했는데 아니였다. 일단 이 방법의 수는 피보나치 수열이라서 bottom up 방식으로 이전 수를 기록하고 저장하는 메모방법을 사용했다. 하지만 1000까지 가게되면 수가 커져서 long long을 사용하지 않고 int 만 사용해도 가능하게끔 mod 10007을 사용한 것이었다. 그래서 나도 처음에 틀렸다..

</details>

<details>
<summary> 11/8 <63일차> </summary>

### <실버 4> 18258번 큐 2
- **문제설명** : 큐의 명령 push, pop, size, empty, front, back 을 구현하는 프로그램을 작성하시오.
- **느낀점**: 이번에는 큐 라이브러리를 활용하여 쉽게 풀었다. 

</details>

<details>
<summary> 11/9 <64일차> </summary>

### <브론즈 5> 9654번 나부 함대 데이터
- **문제설명** : 나부 행성의 함대 정보를 출력하는 프로그램을 작성하시오.
- **느낀점** : 그냥 출력하는 문제였다.

</details>

<details>
<summary> 11/10 <65일차> </summary>

### <브론즈 5> 27433번 팩토리얼 2
- **문제설명** : 0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.
- **느낀점** : 재귀함수를 사용하여 쉽게 풀 수 있었다. 하지만 20 팩토리얼의 경우 int 범위를 벗어난다는것을 깜빡하여 틀렸다. 

</details>

<details>
<summary> 11/11 <66일차> </summary>

### <브론즈 2> 10870번 피보나치 수 5
- **문제설명** : 피보나치 수를 구하는 프로그램을 재귀함수로 구현하라
- **느낀점** : 이 또한 이미 알고있는 문제여서 쉽게 풀었다.

</details>

<details>
<summary> 11/12 <67일차> </summary>

### <실버 3> 11727번 2xn 타일링 2
- **문제설명** : 2×n 직사각형을 1×2, 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.
- **느낀점** : 2xn 타일링 1 과 유사한 문제라 똑같이 dp로 풀면 될거라 생각했지만 2x2 타일이 추가되어 1보다 훨씬 많은 방법의 수가 있었다. 규칙을 찾는 데 시간을 많이 썼다. 규칙은 n 이전의 방법의 수를 모두 더한 다음 짝수인지 홀수인지에 따라 +1, +2를 한다. 예를 들어, n이 5라면 n이 1일때부터 4일때까지의 채우는 방법의 수를 모두 더한 값에 +1을 해주면 그것이 2x5 직사각형을 타일들로 채우는 방법의 수이다. 

### <실버 2> 1260번 DFS와 BFS
- **문제설명** : 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.
- **느낀점** : 다시 한번 dfs와 bfs를 복습할 수 있었다. dfs는 stack을 활용하고, bfs는 queue를 사용한다는 것을 복기했다. 

</details>

<details>
<summary> 11/13 <68일차> </summary>

### <실버 1> 1149번 RGB거리
- **문제설명** : RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.
집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.
1번 집의 색은 2번 집의 색과 같지 않아야 한다.
N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.
- **느낀점** : 챗지피티의 힌트를 얻어서 풀었다보니 푼거같지가 않다.. 내일 다시 풀어봐야겠다. 

</details>

<details>
<summary> 11/14 <69일차> </summary>

### <실버 5> 1676번 팩토리얼 0의 개수
- **문제설명** : N!에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하시오.
- **느낀점** : 처음에는 팩토리얼을 구한후, string배열에 저장해 0을 찾는 방식의 알고리즘을 생각했다. 하지만 팩토리얼은 기하급수적으로 커지면 long long int 자료형을 벗어나기 때문에 이 방식은 불가능하다. 규칙을 찾다가 1부터 n까지 2와 5의 개수를 알아내면 0의 개수를 알아낼 수 있다는 것을 찾았다. 이 규칙에 따라 반복문을 돌면서 곱해지는 수 i의 2와 5의 개수를 찾고 둘 중 작은 개수가 0의 개수임을 알아냈다. (2와 5는 짝이 맞아야하므로)

</details>

<details>
<summary> 11/15 <70일차> </summary>

### <실버 4> 17219번 비밀번호 찾기
- **문제설명** : 첫째 줄에 저장된 사이트 주소의 수 N(1 ≤ N ≤ 100,000)과 비밀번호를 찾으려는 사이트 주소의 수 M(1 ≤ M ≤ 100,000)이 주어진다.
두번째 줄부터 N개의 줄에 걸쳐 각 줄에 사이트 주소와 비밀번호가 공백으로 구분되어 주어진다. 사이트 주소는 알파벳 소문자, 알파벳 대문자, 대시('-'), 마침표('.')로 이루어져 있고, 중복되지 않는다. 비밀번호는 알파벳 대문자로만 이루어져 있다. 모두 길이는 최대 20자이다.
N+2번째 줄부터 M개의 줄에 걸쳐 비밀번호를 찾으려는 사이트 주소가 한줄에 하나씩 입력된다. 이때, 반드시 이미 저장된 사이트 주소가 입력된다.
- **느낀점** : unordered map을 사용하여 O(1) 의 시간복잡도로 해결되는 코드를 작성했다. 

</details>

<details>
<summary> 11/16 <71일차> </summary>

### <실버 2> 2108번 통계학
- **문제설명** : 주어진 숫자 n개에 대해 산술평균, 중앙값, 최빈값, 범위를 구하는 프로그램을 작성하시오
- **느낀점** : 평균을 구할때에는 간단하게 구할 수 있을거라 생각했는데 소수점 첫번째 자리에서 반올림해야하는 조건때문에 cmath 라이브러리의 round 함수를 활용해야했다. 중앙값과 범위는 vector에 입력받은 수들을 저장한 후, sort 함수로 정렬하여 구했다. 최빈값은 map을 활용하여 각 숫자별로 몇번나왔는지 저장했다. 여기서 map을 순회하며 각 원소에 접근하는 코드도 배울 수 있었다. 

</details>

<details>
<summary> 11/17 <72일차> </summary>

### <실버 3> 9375번 패션왕 신해빈
- **문제설명** : 첫째 줄에 테스트 케이스가 주어진다. 테스트 케이스는 최대 100이다.
각 테스트 케이스의 첫째 줄에는 해빈이가 가진 의상의 수 n(0 ≤ n ≤ 30)이 주어진다.
다음 n개에는 해빈이가 가진 의상의 이름과 의상의 종류가 공백으로 구분되어 주어진다. 같은 종류의 의상은 하나만 입을 수 있다.
모든 문자열은 1이상 20이하의 알파벳 소문자로 이루어져있으며 같은 이름을 가진 의상은 존재하지 않는다.
- **느낀점** : 의상종류개수를 저장하는 건 map을 활용해서 코드를 작성할 수 있었는데 각기 다른 종류의 조합으로 입는 경우의 수를 어떻게 구할지 몰랐다. 각기 다른 종류의 수가 3개고, 각 종류마다 3벌, 2벌, 1벌이라면 1벌만 입는 경우, 2벌을 조합하는 경우, 3벌을 조합하는 경우를 다 더한 값인데 이걸 구하는 공식을 몰랐었다. (3+1)*(2+1)*(1+1) - 1 이렇게 계산하면 되었다...  깨달았다.. 안넣는 경우를 추가해서 +1이 되는거다. 그리고 -1을 하는 이유는 아무것도 안입는 경우는 빼야하기 때문이다. 

</details>

<details>
<summary> 11/18 <73일차> </summary>

### <실버 3> 20920번 영단어 암기는 괴로워
- **문제설명** : 화은이는 이번 영어 시험에서 틀린 문제를 바탕으로 영어 단어 암기를 하려고 한다. 그 과정에서 효율적으로 영어 단어를 외우기 위해 영어 단어장을 만들려 하고 있다. 화은이가 만들고자 하는 단어장의 단어 순서는 다음과 같은 우선순위를 차례로 적용하여 만들어진다.
1. 자주 나오는 단어일수록 앞에 배치한다.
2. 해당 단어의 길이가 길수록 앞에 배치한다.
3. 알파벳 사전 순으로 앞에 있는 단어일수록 앞에 배치한다
$M$보다 짧은 길이의 단어의 경우 읽는 것만으로도 외울 수 있기 때문에 길이가 
$M$이상인 단어들만 외운다고 한다
- **느낀점** : 먼저 map에 저장하면 알파벳 사전순(key 기준)으로 정렬해주기 때문에 map으로 단어들을 입력받았다. 그리고 이차원 벡터배열을 만들어 같은 등장 횟수일때는 길이가 긴 순으로 다시 정렬해주었다. 조건이 세개여서 순서대로 처리하느라 각각 적합한 자료형을 사용해야해서 어려웠다. 매번 잊는거같은데 벡터는 배열 크기와 함께 선언해주지않으면 특정 인덱스에 접근할 수 없다. 

</details>

<details>
<summary> 11/19 <74일차> </summary>

### <실버 3> 2579번 계단 오르기
- **문제설명** : 계단 오르는 데는 다음과 같은 규칙이 있다.
계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
마지막 도착 계단은 반드시 밟아야 한다.
따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.
각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.
- **느낀점** : dp 문제인 1149번을 풀때마다 점화식 세우는게 제일 어렵다. i-2번째 계단에서 한 계단을 올라온 경우와 i-3 번째 계단에서 두 계단을 올라오는 경우로 나누어서 점화식을 세우는 생각을 못했다. 
챗지피티 말로는 DP는 “이전 결과 중 최선 + 현재 단계의 선택 비용”을 반복하면서, 중복되는 계산을 저장해두는 최적화 알고리즘입니다. 라고 한다. 
DP 점화식 공식 : “현재 상태 = 이전 가능한 상태 중 최선 + 현재 단계의 비용(또는 보상)”

</details>

<details>
<summary> 11/20 <75일차> </summary>

### <실버 1> 정수 삼각형
- **문제설명** : 위 그림은 크기가 5인 정수 삼각형의 한 모습이다.
맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.
삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.
- **느낀점** : 이제 다이나믹 프로그래밍의 감을 조금 잡은 것같다고 느꼈다. 왜냐? 챗지피티 도움 없이 풀었기때문이다. 규칙이 좀 간단했고 2차원 배열로 구현하면 돼서 쉽게 푼거같다. 


</details>


<details>
<summary> 11/21 <76일차> </summary> <다시풀기>

### <실버 2> 11053번 가장 긴 증가하는 부분 수열
- **문제설명** : 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오. 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.
- **느낀점** : 수열을 순회하면서 만약 이전 원소들 중에 현재 원소보다 작은 원소가 나오면 해당 원소의 dp값 + 1과 현재 원소의 dp값을 비교해 큰 값을 저장하는 방식의 코드였다. 이런 로직을 아직은 내가 생각해내지 못한다. 

</details>

<details>
<summary> 11/22 <77일차> </summary> <다시풀기>

### <실버 2> 11055번 가장 큰 증가하는 부분 수열
- **문제설명** : 수열 A가 주어졌을 때, 그 수열의 증가하는 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오.
예를 들어, 수열 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 인 경우에 합이 가장 큰 증가하는 부분 수열은 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 이고, 합은 113이다.
- **느낀점** : 11053번 코드를 바탕으로 dp 코드를 작성하여 해결했다. 처음에는 그냥 현재 원소보다 작은 원소의 dp에 현재 원소값을 더하는 식으로 코드를 짰다. 하지만 그렇게 작성하면 "가장 큰 값"을 구하지 못한다. 그래서 각 원소들마다 이전 원소값 중 제일 작은 원소값의 인덱스를 저장하는 배열을 만들었다. 그리고 이 인덱스를 기준으로 현재 작은 원소의 dp값과 비교하여 dp값에 저장하도록 했다. 

</details>

<details>

<summary> 11/23 <78일차> </summary> 

### <실버 3> 9461번 파도반 수열
- **문제설명** : 오른쪽 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.
파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.
N이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.
- **느낀점** : 10개까지 봤을때는 어떤 규칙을 가지고있는지 몰랐는데 그림으로 그려보니까 8번째부터 규칙을 가지고 있었다. 현재 원소는 이전 원소와 5번째 전의 원소의 합이다. 그래서 아래처럼 점화식을 세울 수 있었다. 
```
dp[i] = dp[i - 1] + dp[i - 5];
```

</details>

<details>

<summary> 11/24 <79일차> </summary> 

### <실버 5> 4673번 셀프 넘버
- **문제설명** : 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다. 
생성자가 없는 숫자를 셀프 넘버라고 한다. 
10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.
- **느낀점** : 먼저 while문을 돌며 자리수를 더하고 그 값을 return 하는 함수를 만들었다. 그리고 10000보다 작은 d(n)에 대해서 dp 배열을 만들고 저장했다. 문제에서 요구하는 셀프넘버는 이 dp배열에 없는 숫자들을 출력하면 된다. 

</details>

<details>
<summary> 11/25 <80일차> </summary> 

### <실버 2> 1912번 연속합
- **문제설명** : n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.
- **느낀점** : dp의 핵심인 이전 선택에서 최선의 값과 현재 값을 더하는 로직을 적용해서 이전 dp에 현재값을 더했을때 음의 값(-)이 나오면 현재값을 저장하고 아니라면 이전 dp에 현재값을 더한 값과 현재값을 비교하여 더 큰 값을 저장하는 알고리즘으로 코드를 작성했다. 후자의 예시로는 -1, 3이라면 양수이긴 하지만 -1 + 3 = 2 < 3이기 때문에 현재값만 선택하는 것이 더 최선이다. 

</details>

<details>
<summary> 11/26 <81일차> </summary> 

### <실버 4> 1065번 한수
- **문제설명** : 어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오. 
- **느낀점** : 1~99까지는 연속된 두개의 수의 차이가 없기때문에 모두 한수이다. 100부터 각 자리의 수를 구하고 각 자리수의 차이가 같은지 아닌지 판단하고 개수를 세는 방식으로 코드를 작성했다. 

</details>

<details>
<summary> 11/27 <82일차> </summary>

### <실버 3> 15469번 N과 M (1) <다시풀기>
- **문제설명** : 자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.
1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
- **느낀점** : 집중이 너무 안돼서 코드가 잘 이해가 안된다. 내일 다시 풀어보겠다.

</details>

<details>
<summary> 11/28 <83일차> </summary>

### <실버 3> 15650번 N과 M (2)
- **문제설명** : 자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.
1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
고른 수열은 오름차순이어야 한다.
- **느낀점** : 순열은 백트래킹(visited 배열 사용)으로 풀고 조합은 재귀로 푸는 것 같다. 

</details>

<details>
<summary> 11/29 <84일차> </summary>

### <실버 3> 15651번 N과 M (3)
- **문제설명** : 자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.
1부터 N까지 자연수 중에서 M개를 고른 수열
같은 수를 여러 번 골라도 된다.
- **느낀점** : 중복순열을 구현하는 코드여서 15649번의 코드에서 visited 를 사용하는 부분만 뺐다. 이제 조금씩 알것같다.

</details>

<details>
<summary> 11/29 <84일차> </summary>

### <실버 3> 15652번 N과 M (4)
- **문제설명** : 자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.
1부터 N까지 자연수 중에서 M개를 고른 수열
같은 수를 여러 번 골라도 된다.
고른 수열은 비내림차순이어야 한다.
길이가 K인 수열 A가 A1 ≤ A2 ≤ ... ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.
- **느낀점** : 기본 중복 순열 코드에서 재귀할 때 조건을 추가했다. depth가 0이거나 담아놓은 배열의 이전 원소보다 클때만 재귀할 수 있어야하기때문이다. 

</details>

<details>
<summary> 2026년 1월 1일 <86일차> </summary>

### <실버 5> 1476번 날짜 계산
- **문제설명** : 지구를 나타내는 수를 E, 태양을 나타내는 수를 S, 달을 나타내는 수를 M이라고 했을 때, 이 세 수는 서로 다른 범위를 가진다. (1 ≤ E ≤ 15, 1 ≤ S ≤ 28, 1 ≤ M ≤ 19) E, S, M이 주어졌고, 1년이 준규가 사는 나라에서 1 1 1일때, 준규가 사는 나라에서 E S M이 우리가 알고 있는 연도로 몇 년인지 구하는 프로그램을 작성하시오.
- **느낀점** : 이 문제 푸는데 1시간 이상 걸렸다는게 놀랍다. 한달정도 쉬었다고 이렇게나 코딩하는게 어색하게 느껴지다니;; 
- **문제풀이** : 먼저 구해야하는 '알고 있는 연도로 몇 년인지'를 상수인 29로 두고 while 반복문으로 조건에 충족할때까지 값을 늘려가는 식으로 풀었다. '우리가 알고 있는 연도' 이 값을 output이라는 변수로 두었다. output이 되는 조건은 output에서 입력받은 세 수 e, s, m을 각각 뺀 값들이 15, 28, 19에 나누어 떨어져야한다. 

</details>

<details>
<summary> 1/2 <87일차> </summary>

### <실버 5> 9655번 돌 게임
- **문제설명** : 돌 게임은 두 명이서 즐기는 재밌는 게임이다.
탁자 위에 돌 N개가 있다. 상근이와 창영이는 턴을 번갈아가면서 돌을 가져가며, 돌은 1개 또는 3개 가져갈 수 있다. 마지막 돌을 가져가는 사람이 게임을 이기게 된다.
두 사람이 완벽하게 게임을 했을 때, 이기는 사람을 구하는 프로그램을 작성하시오. 게임은 상근이가 먼저 시작한다.
- **느낀점** : 코드근육을 돌아오게 하려면 일주일은 필요할 것으로 보인다. 그래도 이번 문제는 쉬워서 빨리 풀었다. 
- **문제풀이** : 수들의 규칙을 파악했을때 홀수이면 상근이가 이기고 짝수이면 창영이가 이긴다. 

</details>

<details>
<summary> 1/3 <88일차> </summary>

### <실버 5> 1439번 뒤집기
- **문제설명** :다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.
예를 들어 S=0001100 일 때,
전체를 뒤집으면 1110011이 된다.
4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.
하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.
문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.
- **느낀점** : 이번 문제는 그래도 빨리 규칙을 알아내서 30분정도 걸린거같다
- **문제풀이** : 문자열은 0과 1로 이루어져있다. 먼저 이 문자열에서 바뀌는 구간이 있는지 체크한다. 그리고 이 문자열을 구성하는 0의 묶음과 1의 묶음이 (연속적으로 묶인 집단) 몇개가 나오는지 체크한다. 만약 문자열이 하나의 숫자로만 이루어져있다면 바꿀 필요가 없기때문에 0회이다. 아니라면 묶음의 개수가 더 적은 집단을 선택한다. 000110010의 경우 0의 집단은 3개고 1은 2개이므로 2번만에 같은 숫자로 만들 수 있다. 

</details>

<details>
<summary> 1/4 <89일차> </summary>

### <실버 5> 11004 k번째 수
- **문제설명** : 수 N개 A1, A2, ..., AN이 주어진다. A를 오름차순 정렬했을 때, 앞에서부터 K번째 있는 수를 구하는 프로그램을 작성하시오.
- **느낀점** : 라이브러리를 사용하여 쉽게 풀었다. 500만개정도의 많은 입력이 들어오면 ios_base와 cin.tie를 사용하는걸 잊지말아야겠다.


</details>

<details>
<summary> 1/5 <90일차> </summary>

### <실버 5> 1789번 수들의 합
- **문제설명** :서로 다른 N개의 자연수의 합이 S라고 한다. S를 알 때, 자연수 N의 최댓값은 얼마일까?
- **느낀점** : 누적합이라고 생각해서 dp처럼 풀려고 했는데 굳이 그럴필요가 없었다. 10만번 계산 내외로 답이 나오기 때문에 while문을 사용하여 조건에 맞으면 break하는 방식으로 풀면되었다. 


</details>

<details>
<summary> 1/6 <91일차> </summary>

### <실버 5> 2167 2차원 배열의 합
- **문제설명** : 2차원 배열이 주어졌을 때 (i, j) 위치부터 (x, y) 위치까지에 저장되어 있는 수들의 합을 구하는 프로그램을 작성하시오. 배열의 (i, j) 위치는 i행 j열을 나타낸다.
- **느낀점** : 2차원 배열 벡터를 사용해서 쉽게 풀 수 있었다. (i, j)와 (x, y) 좌표를 0-index라고 생각해서 오류가 났었다. 

</details>

<details>
<summary> 1/7 <92일차> </summary>

### <실버 5> 11728번 
- **문제설명** : 정렬되어있는 두 배열 A와 B가 주어진다. 두 배열을 합친 다음 정렬해서 출력하는 프로그램을 작성하시오.
- **느낀점** : 두 배열의 크기를 더한만큼 숫자를 입력받아서 하나의 배열에 저장후 그 배열을 정렬하는식으로 풀었다. 쉽다쉬워!!!

</details>

<details>
<summary> 1/8 <93일차> </summary>

### <실버 5> 14916번 거스름돈
- **문제설명** : 손님이 2원짜리와 5원짜리로만 거스름돈을 달라고 한다. 2원짜리 동전과 5원짜리 동전은 무한정 많이 가지고 있다. 동전의 개수가 최소가 되도록 거슬러 주어야 한다. 거스름돈이 n인 경우, 최소 동전의 개수가 몇 개인지 알려주는 프로그램을 작성하시오.
- **느낀점** : 처음에는 5원으로만 거스름돈을 내는 경우와 2원과 5원의 조합으로 거스름돈은 내는 경우 2가지만 생각하고 코드를 작성했다. 그랬더니 6이나 8같은 2원으로만 거스름돈을 내는 경우를 포함하지 못했다. 

</details>

<details>
<summary> 1/9 <94일차> </summary>

### <실버 5> 1543번 문서 검색
- **문제 설명** : 세준이는 문서와 검색하려는 단어가 주어졌을 때, 그 단어가 최대 몇 번 중복되지 않게 등장하는지 구하는 프로그램을 작성하시오.
- **느낀점** : string이나 getline같은 문법도 이제는 좀 외워야할텐데..
- **문제풀이** : 처음에는 띄어쓰기를 포함하지 않고 생각했다. 테스트케이스보고 입력받을때 getline 사용하는걸로 바꿨다. 로직은 앞에서부터 검색하려는 단어 크기만큼 일치하는지 체크하는것으로 코드를 작성했다. 

</details>

<details>
<summary> 1/10 <95일차> </summary>

### <실버 5> 2018번 수들의 합
- **문제설명** : 어떠한 자연수 N은, 몇 개의 연속된 자연수의 합으로 나타낼 수 있다. 당신은 어떤 자연수 N(1 ≤ N ≤ 10,000,000)에 대해서, 이 N을 몇 개의 연속된 자연수의 합으로 나타내는 가지수를 알고 싶어한다. 이때, 사용하는 자연수는 N이하여야 한다. N을 입력받아 가지수를 출력하는 프로그램을 작성하시오.
- **느낀점** : 연속된 자연수의 합을 어떻게 구해야할지 생각할때는 멘붕이었는데 그건 for문을 사용하면 쉽게 풀리는 문제였다. 그리고 입력이 20만을 넘어가면 시간초과가 나서 어떻게 해결하지 하다가 질문 게시판 보고 깨달았다. 연속된 자연수의 합이 입력받은 n보다 커지는 순간부터는 바로 반복문을 탈출하게 하는 것이었다. 이 부분이 생각보다 시간이 많이 소요된다고 한다. 

</details>

<details>
<summary> 2/24 <1일차> </summary>

- **느낀점** : 실버5단계 문제는 고민하다가 적절한 라이브러리도 맞추지못하는 내모습을 보고 충격받았다. 결국 브론즈1단계 문제를 풀었다. 큐랑 스택 문제를 좀 다시 복습해야겠다.

</details>

<details>
<summary> 2/25 <2일차> </summary>

- 입력이 한자리수 아니면 두자리수여서 조건을 많이 나누지 않아도 됐다. while 반복문 이전에 한번 새로운 수를 만들었어야했다. 그래야 새로운 수에 해당하는 변수만으로 while문을 돌릴수있었기때문이다. 

</details>

<details>
<summary> 2/26 <3일차> </summary>

- 입력받은 수를 2로 계속 나누면서 나오는 나머지로 이진수를 만들 수 있기때문에 해당 방법을 사용했고 나머지가 1일때 출력할 string변수에 추가하는 식으로 마무리했다. 

</details>

<details>
<summary> 2/27 <4일차> </summary>

- 먼저 일주일마다 같은 요일이 돌아온다는 특징을 사용했다. 그리고 1월 1일부터 x월 y일까지의 일수를 다 더하여 7로 나눈 나머지가 무엇이냐에 따라 월화수목금토일을 출력하도록 했다.

</details>